(******************************************************************************)
(* Copyright (c) 2019 Dominique Devriese, Georgy Lukyanov,                    *)
(*   Sander Huyghebaert, Steven Keuchel                                       *)
(* All rights reserved.                                                       *)
(*                                                                            *)
(* Redistribution and use in source and binary forms, with or without         *)
(* modification, are permitted provided that the following conditions are     *)
(* met:                                                                       *)
(*                                                                            *)
(* 1. Redistributions of source code must retain the above copyright notice,  *)
(*    this list of conditions and the following disclaimer.                   *)
(*                                                                            *)
(* 2. Redistributions in binary form must reproduce the above copyright       *)
(*    notice, this list of conditions and the following disclaimer in the     *)
(*    documentation and/or other materials provided with the distribution.    *)
(*                                                                            *)
(* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        *)
(* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  *)
(* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR *)
(* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR          *)
(* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *)
(* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *)
(* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *)
(* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *)
(* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *)
(* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *)
(* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *)
(******************************************************************************)

From Coq Require Import
     Bool.Bool
     Strings.String
     ZArith.BinInt.

From Equations Require Import
     Equations.
From Katamaran Require Import
     Environment
     Notation
     Prelude
     Syntax.BinOps
     Syntax.Terms
     Syntax.TypeDecl
     Syntax.TypeDef
     Syntax.Variables
     Tactics.

Import ctx.notations.
Import env.notations.

Local Set Implicit Arguments.

Module Type InstantiationOn
  (Import TY : Types)
  (Import BO : BinOpsOn TY)
  (Import TM : TermsOn TY BO).

  Local Notation LCtx := (NCtx ùë∫ Ty).
  Local Notation Valuation Œ£ := (@Env (Binding ùë∫ Ty) (fun xt : Binding ùë∫ Ty => Val (@type ùë∫ Ty xt)) Œ£).
  Local Notation CStore := (@NamedEnv ùëø Ty Val).

  (* This type class connects a symbolic representation of a type with its
     concrete / semi-concrete counterpart. The method 'inst' will instantiate
     all logic variables in a symbolic value to obtain the concrete value and
     'lift' injects the concrete type into the symbolic one. *)
  Class Inst (T : LCtx -> Type) (A : Type) : Type :=
    { inst {Œ£} (t : T Œ£) (Œπ : Valuation Œ£) : A;
      lift {Œ£} (a : A) : T Œ£;
    }.

  Global Instance instantiate_list {T : LCtx -> Type} {A : Type} `{Inst T A} :
    Inst (List T) (list A) :=
    {| inst Œ£ xs Œπ := List.map (fun x => inst x Œπ) xs;
       lift Œ£      := List.map lift;
    |}.

  Global Instance instantiate_const {A} `{finite.Finite A} :
    Inst (Const A) A :=
    {| inst Œ£ x Œπ := x;
       lift Œ£ x   := x;
    |}.

  Global Instance instantiate_env {T : Set} {S : LCtx -> T -> Set}
         {A : T -> Set} {InstSA : forall œÑ : T, Inst (fun Œ£ => S Œ£ œÑ) (A œÑ)}
         {Œì : Ctx T} :
    Inst (fun Œ£ => Env (S Œ£) Œì) (Env A Œì) :=
    {| inst Œ£ xs Œπ := env.map (fun (b : T) (s : S Œ£ b) => inst s Œπ) xs;
       lift Œ£      := env.map (fun (b : T) (a : A b) => lift a)
    |}.

  Fixpoint inst_term {œÉ : Ty} {Œ£ : LCtx} (t : Term Œ£ œÉ) (Œπ : Valuation Œ£) {struct t} : Val œÉ :=
    match t in Term _ œÉ return Val œÉ with
    | @term_var _ _ _ bIn  => env.lookup Œπ bIn
    | term_val _ v         => v
    | term_binop op e1 e2  => eval_binop op (inst_term e1 Œπ) (inst_term e2 Œπ)
    | term_neg e           => Z.opp (inst_term e Œπ)
    | term_not e           => negb (inst_term e Œπ)
    | term_inl e           => @inl (Val _) (Val _) (inst_term e Œπ)
    | term_inr e           => @inr (Val _) (Val _) (inst_term e Œπ)
    | @term_projtup _ œÉs e n œÉ p => tuple_proj œÉs n œÉ (inst_term e Œπ) p
    | @term_union _ U K e     => ùëº_fold (existT K (inst_term e Œπ))
    | @term_record _ R ts     =>
        let InstTerm :=
          fun xt : Binding ùëπùë≠ Ty => {| inst := @inst_term (@type ùëπùë≠ Ty xt);
                                 lift Œ£ := @term_val Œ£ (@type ùëπùë≠ Ty xt) |} in
        ùëπ_fold (inst (Inst := instantiate_env (InstSA := InstTerm)) ts Œπ)
    end.

  Global Instance instantiate_term {œÉ} : Inst (fun Œ£ => Term Œ£ œÉ) (Val œÉ) :=
    {| inst Œ£ t Œπ := inst_term t Œπ;
       lift Œ£ v   := term_val œÉ v;
    |}.

  Global Instance instantiate_sub {Œ£} : Inst (Sub Œ£) (Valuation Œ£) :=
    instantiate_env.

  Class InstLaws (T : LCtx -> Type) (A : Type) `{SubstLaws T, Inst T A} : Prop :=
    { inst_lift {Œ£} (Œπ : Valuation Œ£) (a : A) :
        inst (lift a) Œπ = a;
      inst_subst {Œ£ Œ£'} (Œ∂ : Sub Œ£ Œ£') (Œπ : Valuation Œ£') (t : T Œ£) :
        inst (subst t Œ∂) Œπ = inst t (inst Œ∂ Œπ)
    }.

  Global Arguments InstLaws T A {_ _ _}.

  Global Instance instantiatelaws_term {œÉ} : InstLaws (fun Œ£ => Term Œ£ œÉ) (Val œÉ).
  Proof.
    constructor.
    { reflexivity. }
    { induction t; cbn; try (f_equal; auto; fail).
      - now rewrite env.lookup_map.
      - f_equal.
        f_equal.
        apply IHt.
      - f_equal.
        induction es; cbn in *.
        + reflexivity.
        + f_equal.
          * apply IHes, X.
          * apply X.
      (* - f_equal. *)
      (*   f_equal. *)
      (*   apply IHt. *)
    }
  Qed.

  Global Instance instantiatelaws_list {T : LCtx -> Set} {A : Set} `{InstLaws T A} :
    InstLaws (List T) (list A).
  Proof.
    constructor.
    { intros; cbn.
      rewrite List.map_map, <- List.map_id.
      apply List.map_ext, inst_lift.
    }
    { intros ? ? Œ∂ Œπ xs; cbn.
      rewrite substlist_is_map_subst.
      rewrite List.map_map.
      apply List.map_ext, inst_subst.
    }
  Qed.

  Global Instance instantiatelaws_const {A} `{finite.Finite A} :
    InstLaws (Const A) A.
  Proof. constructor; reflexivity. Qed.

  Global Instance instantiatelaws_env {T : Set} {S : LCtx -> T -> Set} {A : T -> Set}
         {_ : forall œÑ : T, Subst (fun Œ£ => S Œ£ œÑ)}
         {_ : forall œÑ : T, SubstLaws (fun Œ£ => S Œ£ œÑ)}
         {_ : forall œÑ : T, Inst (fun Œ£ => S Œ£ œÑ) (A œÑ)}
         {_ : forall œÑ : T, InstLaws (fun Œ£ => S Œ£ œÑ) (A œÑ)}
         {Œì : Ctx T} :
    InstLaws (fun Œ£ => Env (S Œ£) Œì) (Env A Œì).
  Proof.
    constructor.
    { intros; cbn.
      rewrite env.map_map.
      apply env.map_id_eq.
      intros; apply inst_lift.
    }
    { intros ? ? Œ∂ Œπ E; cbn.
      unfold subst, SubstEnv.
      rewrite env.map_map.
      apply env.map_ext.
      intros b s.
      now rewrite inst_subst.
    }
  Qed.

  Global Instance instantiatelaws_sub {Œ£} : InstLaws (Sub Œ£) (Valuation Œ£).
  Proof. apply instantiatelaws_env. Qed.

  Lemma inst_env_snoc {B : Set} {AT : LCtx -> B -> Set}
         {A : B -> Set} {_ : forall b : B, Inst (fun Œ£ => AT Œ£ b) (A b)}
         {Œì : Ctx B} {Œ£} (Œπ : Valuation Œ£) (E : Env (AT Œ£) Œì) (b : B) (a : AT Œ£ b) :
    inst (env.snoc E b a) Œπ = env.snoc (inst E Œπ) b (inst a Œπ).
  Proof. reflexivity. Qed.

  Lemma inst_sub_wk1 {Œ£ b v} (Œπ : Valuation Œ£) :
    inst sub_wk1 (Œπ ‚ñ∫ (b ‚Ü¶ v)) = Œπ.
  Proof.
    apply env.lookup_extensional.
    intros [x œÉ] ?; unfold sub_wk1; cbn.
    now rewrite env.map_tabulate, env.lookup_tabulate.
  Qed.

  Lemma inst_sub_id {Œ£} (Œπ : Valuation Œ£) :
    inst (sub_id Œ£) Œπ = Œπ.
  Proof.
    apply env.lookup_extensional.
    intros [x œÑ] ?; unfold sub_id; cbn.
    now rewrite env.map_tabulate, env.lookup_tabulate.
  Qed.

  Lemma inst_sub_snoc {Œ£0 Œ£1} (Œπ : Valuation Œ£1) (Œ∂ : Sub Œ£0 Œ£1) b (t : Term Œ£1 (type b)) :
    inst (sub_snoc Œ∂ b t) Œπ = env.snoc (inst Œ∂ Œπ) b (inst t Œπ).
  Proof. reflexivity. Qed.

  Lemma inst_sub_up1 {Œ£1 Œ£2 b} (Œ∂12 : Sub Œ£1 Œ£2) (Œπ2 : Valuation Œ£2) (v : Val (type b)) :
    inst (sub_up1 Œ∂12) (Œπ2 ‚ñ∫ (b ‚Ü¶ v)) = inst Œ∂12 Œπ2 ‚ñ∫ (b ‚Ü¶ v).
  Proof.
    destruct b; unfold sub_up1.
    now rewrite inst_sub_snoc, inst_subst, inst_sub_wk1.
  Qed.

  Lemma inst_sub_shift {Œ£} (Œπ : Valuation Œ£) {b} (bIn : b ‚àà Œ£) :
    inst (sub_shift bIn) Œπ = env.remove b Œπ bIn.
  Proof.
    rewrite env.remove_remove'.
    unfold env.remove', sub_shift, inst; cbn.
    apply env.lookup_extensional. intros [y œÑ] yIn.
    now rewrite env.lookup_map, ?env.lookup_tabulate.
  Qed.

  Lemma inst_sub_single_shift {Œ£} (Œπ : Valuation Œ£) {x œÉ} (xIn : x‚à∑œÉ ‚àà Œ£) (t : Term (Œ£ - x‚à∑œÉ) œÉ) :
    inst t (inst (sub_shift xIn) Œπ) = env.lookup Œπ xIn ->
    inst (sub_single xIn t) (inst (sub_shift xIn) Œπ) = Œπ.
  Proof.
    rewrite inst_sub_shift.
    rewrite env.remove_remove'.
    intros HYP. apply env.lookup_extensional. intros [y œÑ] yIn.
    unfold inst, sub_single; cbn.
    rewrite env.lookup_map, env.lookup_tabulate.
    pose proof (ctx.occurs_check_var_spec xIn yIn).
    destruct (ctx.occurs_check_var xIn yIn).
    * dependent elimination e. subst yIn. exact HYP.
    * destruct H; subst yIn. cbn. unfold env.remove'.
      now rewrite env.lookup_tabulate.
  Qed.

  Lemma sub_single_zero {Œ£ : LCtx} {x : ùë∫} {œÉ : Ty} (t : Term Œ£ œÉ) :
    (sub_single ctx.in_zero t) = env.snoc (sub_id Œ£) (x‚à∑œÉ) t.
  Proof.
    eapply env.lookup_extensional.
    intros [x' œÉ'] ([|n] & eq).
    - cbn in *.
      now subst.
    - cbn in *.
      rewrite env.lookup_tabulate; cbn.
      now rewrite lookup_sub_id.
  Qed.

  Lemma inst_sub_single2 {Œ£ : LCtx} {x œÉ} (xIn : x‚à∑œÉ ‚àà Œ£)
        (t : Term (Œ£ - x‚à∑œÉ) œÉ) (Œπ : Valuation (Œ£ - x‚à∑œÉ)) :
    inst (sub_single xIn t) Œπ = env.insert xIn Œπ (inst t Œπ).
  Proof.
    rewrite env.insert_insert'.
    unfold env.insert', sub_single, inst; cbn.
    apply env.lookup_extensional.
    intros [y œÑ] yIn.
    rewrite env.lookup_map, ?env.lookup_tabulate.
    assert (ovs := ctx.occurs_check_var_spec xIn yIn).
    destruct (ctx.occurs_check_var xIn yIn).
    - now dependent elimination e.
    - now reflexivity.
  Qed.

  Lemma inst_lookup {Œ£0 Œ£1} (Œπ : Valuation Œ£1) (Œ∂ : Sub Œ£0 Œ£1) x œÑ (xIn : x‚à∑œÑ ‚àà Œ£0) :
    inst (env.lookup Œ∂ xIn) Œπ = env.lookup (inst (A := Valuation Œ£0) Œ∂ Œπ) xIn.
  Proof. cbn. now rewrite env.lookup_map. Qed.

  Lemma inst_term_tuple {Œ£ œÉs} {Œπ : Valuation Œ£} (es : Env (Term Œ£) œÉs) :
    @eq (EnvRec Val œÉs) (inst (Inst := instantiate_term)(term_tuple es) Œπ)
        (envrec.of_env (inst es Œπ)).
  Proof.
    induction œÉs; cbn.
    - destruct (env.nilView es); now cbn.
    - destruct (env.snocView es); cbn.
      f_equal. now eapply IHœÉs.
  Qed.

  Global Arguments inst {T A _ Œ£} !_ Œπ.
  Global Arguments lift {T A _ Œ£} !_.

  Global Instance InstUnit : Inst Unit unit :=
    @Build_Inst Unit unit (fun _ x Œπ => x) (fun _ x => x).
  Global Instance InstLawsUnit : InstLaws Unit unit.
  Proof. constructor; reflexivity. Qed.

  Global Instance InstPair {AT BT A B} `{Inst AT A, Inst BT B} :
    Inst (Pair AT BT) (A * B) :=
    {| inst Œ£ '(a , b) Œπ := (inst a Œπ, inst b Œπ);
       lift Œ£ '(a, b)    := (lift a , lift b);
    |}.

  Global Instance InstLawsPair {AT BT A B} `{InstLaws AT A, InstLaws BT B} :
    InstLaws (Pair AT BT) (A * B).
  Proof.
    constructor.
    { intros ? ? []; cbn; f_equal; apply inst_lift. }
    { intros ? ? ? ? []; cbn; f_equal; apply inst_subst. }
  Qed.

  Global Instance InstOption {AT A} `{Inst AT A} :
    Inst (Option AT) (option A) :=
    {| inst Œ£ ma Œπ := option_map (fun a => inst a Œπ) ma;
       lift Œ£ ma   := option_map lift ma;
    |}.

  Global Instance InstLawsOption {AT A} `{InstLaws AT A} :
    InstLaws (Option AT) (option A).
  Proof.
    constructor.
    { intros ? ? []; cbn; f_equal; apply inst_lift. }
    { intros ? ? ? ? []; cbn; f_equal; apply inst_subst. }
  Qed.

  Global Program Instance inst_localstore {Œì} : Inst (SStore Œì) (CStore Œì) :=
    instantiate_env.

  Global Instance instlaws_localstore {Œì} : InstLaws (SStore Œì) (CStore Œì).
  Proof. apply instantiatelaws_env. Qed.

  Section Utils.

    Definition term_get_val {Œ£ œÉ} (t : Term Œ£ œÉ) : option (Val œÉ) :=
      match t with
      | term_val _ v => Some v
      | _            => None
      end.

    Lemma term_get_val_spec {Œ£ œÉ} (s : Term Œ£ œÉ) :
      OptionSpec
        (fun v => forall Œπ : Valuation Œ£, inst s Œπ = v)
        True
        (term_get_val s).
    Proof.
      dependent elimination s; cbn; try constructor; auto.
    Qed.

    Equations(noeqns) term_get_pair {Œ£ œÉ1 œÉ2} (t : Term Œ£ (ty_prod œÉ1 œÉ2)) :
      option (Term Œ£ œÉ1 * Term Œ£ œÉ2) :=
      term_get_pair (term_val _ (v1,v2))          := Some (term_val _ v1, term_val _ v2);
      term_get_pair (term_binop binop_pair t1 t2) := Some (t1, t2);
      term_get_pair _ := None.

    Lemma term_get_pair_spec {Œ£ œÉ1 œÉ2} (s : Term Œ£ (ty_prod œÉ1 œÉ2)) :
      OptionSpec
        (fun '(t1,t2) =>
           forall Œπ : Valuation Œ£,
             inst (T := fun Œ£ => Term Œ£ (ty_prod œÉ1 œÉ2)) (A := Val œÉ1 * Val œÉ2) s Œπ =
             (inst (A := Val œÉ1) t1 Œπ, inst (A := Val œÉ2) t2 Œπ))
        True
        (term_get_pair s).
    Proof.
      dependent elimination s; cbn; try constructor; auto.
      - destruct v; constructor; auto.
      - dependent elimination op. constructor. reflexivity.
    Qed.

    Equations(noeqns) term_get_sum {Œ£ œÉ1 œÉ2} (t : Term Œ£ (ty_sum œÉ1 œÉ2)) :
      option (Term Œ£ œÉ1 + Term Œ£ œÉ2) :=
      term_get_sum (term_val _ (inl v)) := Some (inl (term_val _ v));
      term_get_sum (term_val _ (inr v)) := Some (inr (term_val _ v));
      term_get_sum (term_inl t)         := Some (inl t);
      term_get_sum (term_inr t)         := Some (inr t);
      term_get_sum _ := None.

    Lemma term_get_sum_spec {Œ£ œÉ1 œÉ2} (s : Term Œ£ (ty_sum œÉ1 œÉ2)) :
      OptionSpec
        (fun s' => match s' with
                   | inl t => forall Œπ : Valuation Œ£,
                       inst (T := fun Œ£ => Term Œ£ (ty_sum œÉ1 œÉ2)) (A := Val œÉ1 + Val œÉ2) s Œπ =
                       @inl (Val œÉ1) (Val œÉ2) (inst t Œπ)
                   | inr t => forall Œπ : Valuation Œ£,
                       inst (T := fun Œ£ => Term Œ£ (ty_sum œÉ1 œÉ2)) (A := Val œÉ1 + Val œÉ2) s Œπ =
                       @inr (Val œÉ1) (Val œÉ2) (inst t Œπ)
                   end)
        True
        (term_get_sum s).
    Proof.
      dependent elimination s; cbn; try constructor; auto.
      destruct v; constructor; auto.
    Qed.

    Equations(noeqns) term_get_union {Œ£ U} (t : Term Œ£ (ty_union U)) :
      option { K : ùëºùë≤ U & Term Œ£ (ùëºùë≤_Ty K) } :=
      term_get_union (term_val _ v)   :=
        Some (let (K, p) := ùëº_unfold v in existT K (term_val _ p));
      term_get_union (term_union K t) := Some (existT K t);
      term_get_union _ := None.

    Lemma term_get_union_spec {Œ£ U} (s : Term Œ£ (ty_union U)) :
      OptionSpec
        (fun x : {K : ùëºùë≤ U & Term Œ£ (ùëºùë≤_Ty K)} =>
           match x with
           | existT K t =>
             forall Œπ : Valuation Œ£,
               inst (T := fun Œ£ => Term Œ£ (ty_union U)) (A := ùëºùëª U) s Œπ =
               ùëº_fold (@existT (ùëºùë≤ U) (fun K => Val (ùëºùë≤_Ty K)) K (inst t Œπ)) :> Val (ty_union U)
           end)
        True
        (term_get_union s).
    Proof.
      dependent elimination s; cbn; try constructor; auto.
      destruct (ùëº_unfold v) eqn:?. intros. cbn.
      now rewrite <- Heqs, ùëº_fold_unfold.
    Qed.

    Equations(noeqns) term_get_record {R Œ£} (t : Term Œ£ (ty_record R)) :
      option (NamedEnv (Term Œ£) (ùëπùë≠_Ty R)) :=
      term_get_record (term_val _ v)        := Some (lift (ùëπ_unfold v));
      term_get_record (@term_record _ R ts) := Some ts;
      term_get_record _ := None.

    Lemma term_get_record_spec {Œ£ R} (s : Term Œ£ (ty_record R)) :
      OptionSpec
        (fun ts =>
           forall Œπ : Valuation Œ£,
             inst (T := fun Œ£ => Term Œ£ (ty_record R)) (A := ùëπùëª R) s Œπ =
             ùëπ_fold (inst (T := fun Œ£ => NamedEnv (fun œÑ => Term Œ£ œÑ) (ùëπùë≠_Ty R)) (A := NamedEnv Val (ùëπùë≠_Ty R)) ts Œπ))
        True
        (term_get_record s).
    Proof.
      dependent elimination s; try constructor; auto.
      intros Œπ. now rewrite inst_lift, ùëπ_fold_unfold.
    Qed.

    Equations(noeqns) term_get_tuple {œÉs Œ£} (t : Term Œ£ (ty_tuple œÉs)) :
      option (Env (Term Œ£) œÉs) :=
      (* term_get_tuple (term_val _ v)       := Some _; *)
      (* term_get_tuple (@term_tuple _ _ ts) := Some ts; *)
      term_get_tuple _ := None.

    Lemma term_get_tuple_spec {Œ£ œÉs} (s : Term Œ£ (ty_tuple œÉs)) :
      OptionSpec
        (fun ts =>
           forall Œπ : Valuation Œ£,
             inst (T := fun Œ£ => Term Œ£ (ty_tuple œÉs)) (A := Val (ty_tuple œÉs)) s Œπ =
             inst (term_tuple ts) Œπ)
        True
        (term_get_tuple s).
    Proof.
      now constructor.
    Qed.

  End Utils.

End InstantiationOn.
