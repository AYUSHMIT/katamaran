(******************************************************************************)
(* Copyright (c) 2019 Steven Keuchel                                          *)
(* All rights reserved.                                                       *)
(*                                                                            *)
(* Redistribution and use in source and binary forms, with or without         *)
(* modification, are permitted provided that the following conditions are     *)
(* met:                                                                       *)
(*                                                                            *)
(* 1. Redistributions of source code must retain the above copyright notice,  *)
(*    this list of conditions and the following disclaimer.                   *)
(*                                                                            *)
(* 2. Redistributions in binary form must reproduce the above copyright       *)
(*    notice, this list of conditions and the following disclaimer in the     *)
(*    documentation and/or other materials provided with the distribution.    *)
(*                                                                            *)
(* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        *)
(* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  *)
(* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR *)
(* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR          *)
(* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *)
(* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *)
(* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *)
(* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *)
(* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *)
(* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *)
(* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *)
(******************************************************************************)

From Coq Require Import
     Bool.Bool
     Program.Equality
     Program.Tactics
     ZArith.ZArith
     Strings.String
     Classes.Morphisms
     Classes.RelationClasses
     Classes.Morphisms_Prop
     Classes.Morphisms_Relations.
Require Import Basics.

From Coq Require Lists.List.

From Equations Require Import
     Equations.

From MicroSail Require Import
     Sep.Spec
     Sep.Logic
     Sep.Hoare
     Syntax
     Tactics
     Symbolic.Mutator.
From MicroSail Require Import
     SemiConcrete.Mutator
     SemiConcrete.Outcome
     SemiConcrete.Sound.

Set Implicit Arguments.

Import CtxNotations.
Import EnvNotations.

Module Soundness
       (Import termkit : TermKit)
       (Import progkit : ProgramKit termkit)
       (Import assertkit : AssertionKit termkit progkit)
       (Import contractkit : SymbolicContractKit termkit progkit assertkit).
  Module MUT := Mutators termkit progkit assertkit contractkit.
  Import MUT.
  Module LOG := ProgramLogic termkit progkit assertkit contractkit.
  Import LOG.
  Module SCMUT := SemiConcrete.Sound.Soundness termkit progkit assertkit contractkit.
  Import SCMUT.
  Import SCMUT.MUT.

  Local Notation "[ Œπ ] x == y" := (inst Œπ x = inst Œπ y) (at level 50).
  (* Avoid some Prop <-> Type confusion. *)
  Notation instpc Œπ pc := (@inst _ _ instantiate_pathcondition _ Œπ pc).

  Global Instance inst_symbolicstate {Œì} : Inst (SymbolicState Œì) (SCState Œì) :=
    {| inst Œ£ Œπ '(MkSymbolicState Œ¥ h) := MkSCState (inst Œπ Œ¥) (inst Œπ h);
       lift Œ£ '(MkSCState Œ¥ h) := MkSymbolicState (lift Œ¥) (lift h);
    |}.

  Global Instance instlaws_symbolicState {Œì} : InstLaws (SymbolicState Œì) (SCState Œì).
  Proof.
    constructor.
    - intros ? ? []; cbn; now rewrite ?inst_lift.
    - intros ? ? ? ? []; cbn; now rewrite ?inst_subst.
  Qed.

  (* Read: If œÇ is equivalent to t in Œπ, then substituting t for œÇ is equivalent to the identity. *)
  Lemma inst_single_shift {Œ£ œÇ œÉ} (œÇInŒ£ : œÇ :: œÉ ‚àà Œ£) (t : Term (Œ£ - (œÇ :: œÉ)) œÉ) Œπ :
    [ Œπ ] term_var œÇ == subst (sub_shift œÇInŒ£) t ->
    [ Œπ ] sub_comp (sub_single œÇInŒ£ t) (sub_shift œÇInŒ£) == sub_id _.
  Proof.
    unfold sub_comp.
    rewrite ?inst_subst.
    rewrite inst_sub_id.
    rewrite ?inst_sub_shift.
    cbn. intros H.
    now apply inst_sub_single.
  Qed.

  Lemma subst_sub_id_right {Œ£1 Œ£2} (Œ∂ : Sub Œ£1 Œ£2) :
    subst Œ∂ (sub_id _) = Œ∂.
  Proof. exact (sub_comp_id_left Œ∂). Qed.

  Lemma inst_record_pattern_match {Œî__R : NCtx ùëπùë≠ Ty} {Œ£ Œî : LCtx}
    (Œπ : SymInstance Œ£) (p : RecordPat Œî__R Œî) (ts : NamedEnv (Term Œ£) Œî__R) :
    inst Œπ (record_pattern_match p ts) = record_pattern_match p (inst Œπ ts).
  Proof.
    unfold inst at 1; cbn.
    induction p; cbn.
    - reflexivity.
    - destruct (snocView ts); cbn.
      f_equal. apply IHp.
  Qed.

  Section Entailment.

    (* A preorder on path conditions. This encodes that either pc1 belongs to a
       longer symbolic execution path (or that it's the same path, but with
       potentially some constraints substituted away). *)
    Definition entails {Œ£} (pc1 pc0 : PathCondition Œ£) : Prop :=
      forall (Œπ : SymInstance Œ£),
        instpc Œπ pc1 ->
        instpc Œπ pc0.
    Infix "‚ä¢" := (@entails _) (at level 80, no associativity).

    Definition entails_formula {Œ£}
               (pc : PathCondition Œ£) (f : Formula Œ£) : Prop :=
      forall (Œπ : SymInstance Œ£),
        instpc Œπ pc -> (inst Œπ f : Prop).
    Infix "‚ä¢f" := (@entails_formula _) (at level 80, no associativity).

    Lemma entails_cons {Œ£} (pc1 pc2 : PathCondition Œ£) (f : Formula Œ£) :
      (pc1 ‚ä¢ pc2 /\ pc1 ‚ä¢f f) <-> pc1 ‚ä¢ (f :: pc2)%list.
    Proof.
      split.
      - intros (pc12 & pc1f).
        intros Œπ Œπpc1. cbn.
        unfold inst, inst_pathcondition. cbn.
        rewrite fold_right_1_10_prop.
        intuition.
      - intros pc1f2.
        split; intros Œπ Œπpc1;
          specialize (pc1f2 Œπ Œπpc1); cbn in pc1f2;
          unfold inst, inst_pathcondition in pc1f2; cbn in pc1f2;
          rewrite fold_right_1_10_prop in pc1f2;
          destruct pc1f2 as [Hf Hpc2]; auto.
    Qed.

    Global Instance preorder_entails {Œ£} : PreOrder (@entails Œ£).
    Proof.
      split.
      - intuition.
      - intros x y z xy yz Œπ Œπx.
        eauto.
    Qed.

    Global Instance proper_subst_pc_entails {Œ£1 Œ£2} {Œ∂}: Proper ((@entails Œ£1) ==> (@entails Œ£2)) (subst Œ∂).
    Proof.
      intros pc1 pc2 pc12 Œπ.
      rewrite ?inst_subst; eauto.
    Qed.

    Definition entails_eq {AT A} `{Inst AT A} {Œ£} (pc : PathCondition Œ£) (a0 a1 : AT Œ£) : Prop :=
      forall (Œπ : SymInstance Œ£), instpc Œπ pc -> inst Œπ a0 = inst Œπ a1.
    Notation "pc ‚ä¢ a0 == a1" :=
      (entails_eq pc a0 a1)
      (at level 80, a0 at next level, no associativity).

    Global Instance proper_subst_entails_eq {AT A} `{InstLaws AT A} {Œ£1 Œ£2} {Œ∂ : Sub Œ£1 Œ£2} {pc : PathCondition Œ£1} :
      Proper ((entails_eq pc) ==> (entails_eq (subst Œ∂ pc))) (subst Œ∂).
    Proof.
      intros a1 a2 a12 Œπ.
      rewrite ?inst_subst; auto.
    Qed.

    Global Instance proper_subst_entails_eq_pc
           {Œ£1 Œ£2} `{InstLaws AT A}
           (pc : PathCondition Œ£2):
      Proper (entails_eq pc ==> eq ==> entails_eq pc) (@subst AT _ Œ£1 Œ£2).
    Proof.
      intros Œ∂1 Œ∂2 Œ∂12 a1 a2 [] Œπ Œπpc.
      rewrite ?inst_subst.
      now rewrite (Œ∂12 Œπ Œπpc).
    Qed.


    (* Not sure this instance is a good idea...
       This seems to cause rewrite to take very long... *)
    Global Instance proper_entails_pc_iff
           {Œ£} (pc : PathCondition Œ£):
         Proper (entails_eq pc ==> iff) (entails pc).
    Proof.
      intros pc1 pc2 pc12.
      split; intros HYP Œπ Œπpc;
        specialize (pc12 Œπ Œπpc);
        specialize (HYP Œπ Œπpc);
        congruence.
    Qed.

    Global Instance proper_entails_formula_iff
           {Œ£} (pc : PathCondition Œ£):
         Proper (entails_eq pc ==> iff) (entails_formula pc).
    Proof.
      intros pc1 pc2 pc12.
      split; intros HYP Œπ Œπpc;
        specialize (pc12 Œπ Œπpc);
        specialize (HYP Œπ Œπpc);
        congruence.
    Qed.

    Global Instance proper_entails_eq_impl {AT A} {Œ£} {Œì} : Proper (flip (@entails Œ£) ==> eq ==> eq ==> impl) (@entails_eq AT A Œì Œ£).
    Proof.
      intros pc1 pc2 pc21 a1 _ [] a2 _ [] eq1 Œπ Œπpc2; eauto.
    Qed.

    Global Instance proper_entails_eq_flip_impl {AT A} `{Inst AT A} {Œ£} : Proper ((@entails Œ£) ==> eq ==> eq ==> flip impl) entails_eq.
    Proof.
      intros pc1 pc2 pc21 a1 _ [] a2 _ [] eq1 Œπ Œπpc2; eauto.
    Qed.

    Global Instance equiv_entails_eq `{instA : Inst AT A} {Œ£} {pc : PathCondition Œ£} : Equivalence (entails_eq pc).
    Proof.
      split.
      - intuition.
      - intros x y xy Œπ ipc; specialize (xy Œπ); intuition.
      - intros x y z xy yz Œπ ipc.
        specialize (xy Œπ ipc).
        specialize (yz Œπ ipc).
        intuition.
    Qed.

    Global Instance proper_entails_eq_flip_impl_pc {AT A} `{Inst AT A} {Œ£} {pc : PathCondition Œ£}: Proper (entails_eq pc ==> entails_eq pc ==> iff) (entails_eq pc).
    Proof.
      split; intros Heq.
      - transitivity x; [|transitivity x0]; easy.
      - transitivity y; [|transitivity y0]; easy.
    Qed.

    Global Instance proper_entails_eq_sub_comp
           {Œ£1 Œ£2 Œ£3} {Œ∂ : Sub Œ£1 Œ£2} (pc : PathCondition Œ£3):
      Proper (entails_eq pc ==> entails_eq pc) (sub_comp Œ∂).
    Proof.
      intros Œ∂1 Œ∂2 Œ∂12.
      unfold sub_comp; rewrite Œ∂12; easy.
    Qed.

  End Entailment.
  Infix "‚ä¢" := (@entails _) (at level 80, no associativity).
  Infix "‚ä¢f" := (@entails_formula _) (at level 80, no associativity).
  Notation "pc ‚ä¢ a0 == a1" :=
    (entails_eq pc a0 a1)
    (at level 80, a0 at next level, no associativity).

  Section SemiConcreteWP.

    Definition scmut_wp {Œì1 Œì2 A}
      (m : SCMut Œì1 Œì2 A)
      (POST : A -> SCState Œì2 -> Prop)
      (s1 : SCState Œì1) : Prop :=
      outcome_satisfy (m s1) (fun r => POST (scmutres_value r) (scmutres_state r)).

    Lemma scmut_wp_monotonic {A} {Œì1 Œì2} (m : SCMut Œì1 Œì2 A) (s1 : SCState Œì1)
      (P Q : A -> SCState Œì2 -> Prop) (PQ : forall a s, P a s -> Q a s) :
      scmut_wp m P s1 -> scmut_wp m Q s1.
    Proof. unfold scmut_wp. apply outcome_satisfy_monotonic; intros []; apply PQ. Qed.

    Lemma scmut_wp_equiv {A} {Œì1 Œì2} (m : SCMut Œì1 Œì2 A) (s1 : SCState Œì1)
      (P Q : A -> SCState Œì2 -> Prop) (PQ : forall a s, P a s <-> Q a s) :
        scmut_wp m P s1 <-> scmut_wp m Q s1.
    Proof. split; apply scmut_wp_monotonic; apply PQ. Qed.

    Lemma scmut_wp_bind {Œì1 Œì2 Œì3 A B} (ma : SCMut Œì1 Œì2 A) (f : A -> SCMut Œì2 Œì3 B)
          (POST : B -> SCState Œì3 -> Prop) :
      forall s1 : SCState Œì1,
        scmut_wp (scmut_bind ma f) POST s1 <->
        scmut_wp ma (fun a => scmut_wp (f a) POST) s1.
    Proof.
      unfold SCMut, scmut_bind, scmut_wp in *; cbn; intros.
      now rewrite outcome_satisfy_bind.
    Qed.

    Lemma scmut_wp_demonic {Œì1 Œì2 A B} (sm : B -> SCMut Œì1 Œì2 A) (s__sc : SCState Œì1) (POST : A -> SCState Œì2 -> Prop) :
      scmut_wp (scmut_demonic sm) POST s__sc <-> forall v, scmut_wp (sm v) POST s__sc.
    Proof. unfold scmut_wp, scmut_demonic; cbn; intuition. Qed.

    Lemma scmut_wp_demonic_binary {Œì1 Œì2 A} (sm1 sm2 : SCMut Œì1 Œì2 A) (s__sc : SCState Œì1) (POST : A -> SCState Œì2 -> Prop) :
      scmut_wp (scmut_demonic_binary sm1 sm2) POST s__sc <->
      scmut_wp sm1 POST s__sc /\ scmut_wp sm2 POST s__sc.
    Proof. unfold scmut_wp, scmut_demonic_binary; cbn; intuition. Qed.

    Lemma scmut_wp_angelic {Œì1 Œì2 A B} (sm : B -> SCMut Œì1 Œì2 A) (s__sc : SCState Œì1) (POST : A -> SCState Œì2 -> Prop) :
      scmut_wp (scmut_angelic sm) POST s__sc <-> exists v, scmut_wp (sm v) POST s__sc.
    Proof. unfold scmut_wp, scmut_angelic; cbn; intuition. Qed.

    Lemma scmut_wp_angelic_binary {Œì1 Œì2 A} (sm1 sm2 : SCMut Œì1 Œì2 A) (s__sc : SCState Œì1) (POST : A -> SCState Œì2 -> Prop) :
      scmut_wp (scmut_angelic_binary sm1 sm2) POST s__sc <->
      scmut_wp sm1 POST s__sc \/ scmut_wp sm2 POST s__sc.
    Proof. unfold scmut_wp, scmut_angelic_binary; cbn; intuition. Qed.

    Lemma scmut_wp_state {Œì1 Œì2 A} (f : SCState Œì1 -> A * SCState Œì2) (POST : A -> SCState Œì2 -> Prop) :
      forall (s1 : SCState Œì1),
        scmut_wp (scmut_state f) POST s1 <-> POST (fst (f s1)) (snd (f s1)).
    Proof. intros s1. cbn. now destruct (f s1); cbn. Qed.

  End SemiConcreteWP.

  Module TwoPointOSoundness.

    Global Instance InstDynamicMutatorResult {AT A} `{Inst AT A} {Œì} : Inst (DynamicMutatorResult Œì AT) (SCMutResult Œì A).
    Proof.
      constructor.
      - intros ? ? r.
        destruct r as [a s].
        constructor.
        revert a. now apply inst.
        revert s. now apply inst.
      - intros ? r.
        destruct r as [a s].
        constructor.
        apply (lift a).
        apply (lift s).
    Defined.

    Global Instance InstLawsDynamicMutatorResult {AT A} `{InstLaws AT A} {Œì} : InstLaws (DynamicMutatorResult Œì AT) (SCMutResult Œì A).
    Proof.
      constructor.
      - intros ? ? []; cbn; now rewrite ?inst_lift.
      - intros ? ? ? ? []; cbn; now rewrite ?inst_subst.
    Qed.

    Lemma sout_arrow_dcl_eta {AT A BT B} `{Subst AT, Subst BT, Inst AT A, Inst BT B} {Œì Œ£1} (f : sout_arrow (DynamicMutatorResult Œì AT) BT Œ£1) :
      sout_arrow_dcl
        (AT := DynamicMutatorResult Œì AT)
        (fun Œ£2 Œ∂12 pc2 r =>
           f Œ£2 Œ∂12 pc2 {| dmutres_result_value := dmutres_result_value r; dmutres_result_state := dmutres_result_state r |}) ->
      sout_arrow_dcl f.
    Proof.
      intros HYP Œ£2 Œ£3 Œ∂12 Œ∂13 pc2 pc3 Œ∂23 r2 r3 F P Q PQ Œπ2 Œπ3;
        specialize (HYP Œ£2 Œ£3 Œ∂12 Œ∂13 pc2 pc3 Œ∂23 r2 r3 F P Q PQ Œπ2 Œπ3);
        destruct r2, r3; intuition.
    Qed.

    Lemma sout_arrow_dcl_pure {BT B} `{Subst ET, Subst BT, Inst BT B} {Œì3 Œ£1} :
        sout_arrow_dcl
          (fun (Œ£3 : LCtx) (_ : Sub Œ£1 Œ£3) (_ : PathCondition Œ£3) (X : DynamicMutatorResult Œì3 BT Œ£3) =>
             match X with
             | MkDynMutResult b3 Œ¥3 => sout_pure (MkDynMutResult b3 Œ¥3)
             end).
    Proof. unfold sout_arrow_dcl. destruct a1, a2. cbn. intuition. Qed.

    Definition dmut_arrow Œì1 Œì2 AT BT Œ£0 : Type :=
      forall Œ£1, Sub Œ£0 Œ£1 -> AT Œ£1 -> DynamicMutator Œì1 Œì2 BT Œ£1.

    Definition dmut_wp {AT A} `{Inst AT A} {Œì1 Œì2 Œ£0} (d : DynamicMutator Œì1 Œì2 AT Œ£0)
      {Œ£1} (Œ∂01 : Sub Œ£0 Œ£1) (pc1 : PathCondition Œ£1) (s1 : SymbolicState Œì1 Œ£1)
      (Œπ1 : SymInstance Œ£1) (P : A -> SCState Œì2 -> Prop) : Prop.
    Proof.
      unfold DynamicMutator in d.
      refine (sout_wp (d Œ£1 Œ∂01 pc1 s1) Œπ1 _).
      intros [a sc2].
      apply (P a sc2).
    Defined.

    Ltac fold_dmut_wp :=
      match goal with
      | |- context[sout_wp (?d ?Œ£ ?Œ∂ ?pc ?s) ?Œπ (fun r => ?P _ _)] =>
        change (sout_wp (d Œ£ Œ∂ pc s) Œπ _) with (dmut_wp d Œ∂ pc s Œπ P)
      end.

    Lemma dmut_wp_monotonic {AT A} `{Inst AT A} {Œì1 Œì2 Œ£0 Œ£1} (d : DynamicMutator Œì1 Œì2 AT Œ£0)
      (Œ∂01 : Sub Œ£0 Œ£1) (pc1 : PathCondition Œ£1) (s11 : SymbolicState Œì1 Œ£1) (Œπ1 : SymInstance Œ£1)
      (P Q : A -> SCState Œì2 -> Prop) (PQ : forall a s, P a s -> Q a s) :
        dmut_wp d Œ∂01 pc1 s11 Œπ1 P -> dmut_wp d Œ∂01 pc1 s11 Œπ1 Q.
    Proof.
      unfold dmut_wp. apply sout_wp_monotonic; intros []; apply PQ.
    Qed.

    Lemma dmut_wp_equiv {AT A} `{Inst AT A} {Œì1 Œì2 Œ£0 Œ£1} (d : DynamicMutator Œì1 Œì2 AT Œ£0)
      (Œ∂01 : Sub Œ£0 Œ£1) (pc1 : PathCondition Œ£1) (s11 : SymbolicState Œì1 Œ£1) (Œπ1 : SymInstance Œ£1)
      (P Q : A -> SCState Œì2 -> Prop) (PQ : forall a s, P a s <-> Q a s) :
        dmut_wp d Œ∂01 pc1 s11 Œπ1 P <-> dmut_wp d Œ∂01 pc1 s11 Œπ1 Q.
    Proof.
      unfold dmut_wp. split; apply sout_wp_monotonic; intros []; apply PQ.
    Qed.

    Lemma dmut_wp_pure {AT A} `{InstLaws AT A} {Œì Œ£0 Œ£1} (a0 : AT Œ£0)
      (Œ∂01 : Sub Œ£0 Œ£1) (pc1 : PathCondition Œ£1) (s1 : SymbolicState Œì Œ£1) (Œπ1 : SymInstance Œ£1)
      (P : A -> SCState Œì -> Prop) :
      dmut_wp (dmut_pure (Œì := Œì) a0) Œ∂01 pc1 s1 Œπ1 P <-> P (inst (inst Œπ1 Œ∂01) a0) (inst Œπ1 s1).
    Proof. unfold dmut_wp, dmut_pure; cbn. now rewrite inst_subst. Qed.

    Lemma dmut_wp_fail {AT A D} `{Subst AT, Inst AT A} {Œì1 Œì2 Œ£0 Œ£1} (func msg : string) (data : D) (Œ∂01 : Sub Œ£0 Œ£1)
          (pc1 : PathCondition Œ£1) (s1 : SymbolicState Œì1 Œ£1) (Œπ1 : SymInstance Œ£1)
          (P : A -> SCState Œì2 -> Prop) :
      dmut_wp (dmut_fail func msg data) Œ∂01 pc1 s1 Œπ1 P <-> False.
    Proof. destruct s1; cbn. split; intros []. Qed.

    Lemma dmut_wp_sub {AT A} `{Subst AT, Inst AT A} {Œì1 Œì2 Œ£0 Œ£1 Œ£2} (Œ∂01 : Sub Œ£0 Œ£1) (d : DynamicMutator Œì1 Œì2 AT Œ£0)
      (pc2 : PathCondition Œ£2) (s2 : SymbolicState Œì1 Œ£2) (Œ∂12 : Sub Œ£1 Œ£2) (Œπ2 : SymInstance Œ£2)
      (P : A -> SCState Œì2 -> Prop) :
      dmut_wp (dmut_sub Œ∂01 d) Œ∂12 pc2 s2 Œπ2 P <->
      dmut_wp d (sub_comp Œ∂01 Œ∂12) pc2 s2 Œπ2 P.
    Proof. reflexivity. Qed.

    Definition dmut_geq {Œì1 Œì2 AT Œ£0 A} `{Inst AT A, Subst AT} (d1 d2 : DynamicMutator Œì1 Œì2 AT Œ£0) : Prop :=
      forall Œ£1 Œ£2 (Œ∂01 : Sub Œ£0 Œ£1) pc1 (s1 : SymbolicState Œì1 Œ£1) (Œ∂12 : Sub Œ£1 Œ£2) pc2 s2 Œ∂02 Œπ1 Œπ2,
        Œπ1 = inst Œπ2 Œ∂12 ->
        instpc Œπ1 pc1 ->
        instpc Œπ2 pc2 ->
        inst Œπ1 s1 = inst Œπ2 s2 ->
        inst Œπ1 Œ∂01 = inst Œπ2 Œ∂02 ->
        forall (P Q : A -> SCState Œì2 -> Prop) (PQ : forall a s, P a s -> Q a s),
          dmut_wp d1 Œ∂01 pc1 s1 Œπ1 P ->
          dmut_wp d2 Œ∂02 pc2 s2 Œπ2 Q.

    Definition dmut_dcl {Œì1 Œì2 AT Œ£0 A} `{Inst AT A, Subst AT} (d : DynamicMutator Œì1 Œì2 AT Œ£0) : Prop :=
      dmut_geq d d.

    Definition dmut_arrow_dcl {AT A BT B} `{Subst BT, Inst AT A, Inst BT B} {Œì1 Œì2 Œ£0} (f : dmut_arrow Œì1 Œì2 AT BT Œ£0) : Prop :=
      forall Œ£1 Œ£2 Œ∂01 Œ∂02 a1 a2 Œ£3 Œ£4 Œ∂13 Œ∂24 Œ∂34 pc3 pc4 s3 s4,
      forall (Œπ3 : SymInstance Œ£3) (Œπ4 : SymInstance Œ£4),
        Œπ3 = inst Œπ4 Œ∂34 ->
        instpc Œπ3 pc3 ->
        instpc Œπ4 pc4 ->
        inst Œπ3 (sub_comp Œ∂01 Œ∂13) = inst Œπ4 (sub_comp Œ∂02 Œ∂24) ->
        inst (inst Œπ3 Œ∂13) a1 = inst (inst Œπ4 Œ∂24) a2 ->
        inst Œπ3 s3 = inst Œπ4 s4 ->
        forall (P Q : B -> SCState Œì2 -> Prop) (PQ : forall b s, P b s -> Q b s),
          dmut_wp (f Œ£1 Œ∂01 a1) Œ∂13 pc3 s3 Œπ3 P ->
          dmut_wp (f Œ£2 Œ∂02 a2) Œ∂24 pc4 s4 Œπ4 Q.

    Lemma dmut_arrow_dcl_specialize {AT A BT B} `{Subst BT, Inst AT A, Inst BT B} {Œì1 Œì2 Œ£0}
      (f : dmut_arrow Œì1 Œì2 AT BT Œ£0) (f_dcl : dmut_arrow_dcl f) :
      forall Œ£1 (Œ∂01 : Sub Œ£0 Œ£1) (a1 : AT Œ£1),
        dmut_dcl (f Œ£1 Œ∂01 a1).
    Proof.
      unfold dmut_dcl, dmut_geq. intros until Q; intros PQ.
      eapply f_dcl; eauto; unfold sub_comp; rewrite ?inst_subst; congruence.
    Qed.

    Lemma dmut_pure_dcl {AT A} `{InstLaws AT A} {Œì Œ£} (a : AT Œ£) :
      dmut_dcl (dmut_pure (Œì := Œì) a).
    Proof.
      unfold dmut_dcl, dmut_geq. intros * -> Hpc1 Hpc2 Hs HŒ∂ * PQ.
      rewrite ?dmut_wp_pure. rewrite Hs, HŒ∂. apply PQ.
    Qed.

    Lemma dmut_wp_bind {AT A BT B} `{InstLaws AT A, InstLaws BT B} {Œì1 Œì2 Œì3 Œ£0 Œ£2}
      (d : DynamicMutator Œì1 Œì2 AT Œ£0) (f : dmut_arrow Œì2 Œì3 AT BT Œ£0) (f_dcl : dmut_arrow_dcl f)
      (pc2 : PathCondition Œ£2) (s2 : SymbolicState Œì1 Œ£2) (Œ∂02 : Sub Œ£0 Œ£2) (Œπ2 : SymInstance Œ£2)
      (Q : B -> SCState Œì3 -> Prop) (Hpc2 : instpc Œπ2 pc2) :
      dmut_wp (dmut_bind d f) Œ∂02 pc2 s2 Œπ2 Q <->
      dmut_wp d Œ∂02 pc2 s2 Œπ2 (fun a s => dmut_wp (f _ (sub_id _) (lift a)) Œ∂02 pc2 (lift s) Œπ2 Q).
    Proof.
      unfold dmut_wp, dmut_bind; cbn.
      rewrite sout_wp_bind; auto. split; apply sout_wp_monotonic.
      - intros [a sc2]; cbn. rewrite sub_comp_id_right.
        rewrite sout_wp_bind; try exact sout_arrow_dcl_pure; auto.
        unfold dmut_arrow_dcl, dmut_wp in f_dcl. cbn.
        specialize (f_dcl Œ£2 Œ£0 Œ∂02 (sub_id _) (lift a) (lift a) Œ£2 Œ£2 (sub_id _) Œ∂02 (sub_id _) pc2 pc2 (lift sc2) (lift sc2) Œπ2 Œπ2).
        inster f_dcl by (unfold sub_comp; rewrite ?inst_subst, ?inst_lift, ?inst_sub_id; auto).
        specialize (f_dcl Q Q). inster f_dcl by auto.
        intros Hwp; apply f_dcl; revert Hwp.
        apply sout_wp_monotonic. intros [b sc3]. cbn.
        now rewrite ?inst_lift.
      - intros [a sc2]; cbn. rewrite sub_comp_id_right.
        rewrite sout_wp_bind; try exact sout_arrow_dcl_pure; auto.
        unfold dmut_arrow_dcl, dmut_wp in f_dcl. cbn.
        specialize (f_dcl Œ£0 Œ£2 (sub_id _) Œ∂02 (lift a) (lift a) Œ£2 Œ£2 Œ∂02 (sub_id _) (sub_id _) pc2 pc2 (lift sc2) (lift sc2) Œπ2 Œπ2).
        inster f_dcl by (unfold sub_comp; rewrite ?inst_subst, ?inst_lift, ?inst_sub_id; auto).
        specialize (f_dcl Q Q). inster f_dcl by auto.
        intros Hwp; apply f_dcl in Hwp; revert Hwp.
        apply sout_wp_monotonic. intros [b sc3]. cbn.
        now rewrite ?inst_lift.
      - unfold sout_arrow_dcl. destruct a1 as [a1 s21], a2 as [a3 s23]; cbn. intros.
        revert H12. inversion H11.
        rewrite ?sout_wp_bind; try exact sout_arrow_dcl_pure; auto.
        unfold lift; cbn. setoid_rewrite inst_lift.
        unfold dmut_arrow_dcl, dmut_wp in f_dcl.
        specialize (f_dcl Œ£1 Œ£3 (sub_comp Œ∂02 Œ∂1) (sub_comp Œ∂02 Œ∂2) a1 a3 Œ£1 Œ£3 (sub_id _) (sub_id _) Œ∂12 pc1 pc0 s21 s23 Œπ1 Œπ0).
        inster f_dcl by (try exact HF0; unfold sub_comp; rewrite ?inst_subst, ?inst_sub_id; intuition).
        specialize (f_dcl (fun b s => P (MkSCMutResult b s)) (fun b s => Q0 (MkSCMutResult b s))).
        apply f_dcl; intuition.
    Qed.

    Lemma dmut_wp_fmap {AT A BT B} `{InstLaws AT A, Inst BT B, Subst BT} {Œì1 Œì2 Œ£0 Œ£2}
      (d : DynamicMutator Œì1 Œì2 AT Œ£0) (f : forall Œ£1, Sub Œ£0 Œ£1 -> AT Œ£1 -> BT Œ£1)
      (f_dcl : sout_mapping_dcl f)
      (pc2 : PathCondition Œ£2) (s2 : SymbolicState Œì1 Œ£2) (Œ∂02 : Sub Œ£0 Œ£2) (Œπ2 : SymInstance Œ£2)
      (Q : B -> SCState Œì2 -> Prop) (Hpc2 : instpc Œπ2 pc2) :
      dmut_wp (dmut_fmap d f) Œ∂02 pc2 s2 Œπ2 Q <->
      dmut_wp d Œ∂02 pc2 s2 Œπ2 (fun a : A => Q (inst Œπ2 (f Œ£2 Œ∂02 (lift a)))).
    Proof.
      unfold dmut_fmap, dmut_wp. rewrite sout_wp_map.
      split; apply sout_wp_monotonic; intros [a sc2]; cbn.
      - now rewrite sub_comp_id_right, inst_lift.
      - now rewrite sub_comp_id_right, inst_lift.
      - unfold sout_mapping_dcl. destruct a1 as [a1 s1], a2 as [a3 s3]; cbn.
        intros * -> HŒ∂. inversion 1. f_equal.
        eapply f_dcl; unfold sub_comp; rewrite ?inst_subst; intuition.
    Qed.

    Lemma dmut_wp_pair {AT A BT B} `{InstLaws AT A, InstLaws BT B} {Œì1 Œì2 Œì3 Œ£0 Œ£1}
      (da : DynamicMutator Œì1 Œì2 AT Œ£0) (db : DynamicMutator Œì2 Œì3 BT Œ£0) (db_dcl : dmut_dcl db)
      (Œ∂01 : Sub Œ£0 Œ£1) (pc1 : PathCondition Œ£1) s1 Œπ1 (Hpc : instpc Œπ1 pc1) P :
      dmut_wp (dmut_pair da db) Œ∂01 pc1 s1 Œπ1 P <->
      dmut_wp da Œ∂01 pc1 s1 Œπ1 (fun a sc2 => dmut_wp db Œ∂01 pc1 (lift sc2) Œπ1 (fun b => P (a,b))).
    Proof.
      unfold dmut_pair, dmut_fmap2. rewrite dmut_wp_bind; eauto.
      apply dmut_wp_equiv. intros a sc2. rewrite dmut_wp_fmap; eauto.
      rewrite dmut_wp_sub, sub_comp_id_left.
      apply dmut_wp_equiv. intros b sc3. cbn.
      now rewrite ?inst_subst, ?inst_sub_id, ?inst_lift.
      - unfold sout_mapping_dcl. intros *. cbn.
        rewrite ?inst_subst, ?inst_lift. intuition.
      - intros until Q; intros PQ.
        rewrite ?dmut_wp_fmap; eauto.
        + rewrite ?dmut_wp_sub. eapply db_dcl; eauto.
          intros *. cbn. rewrite ?inst_subst, ?inst_lift, H11.
          intuition.
        + unfold sout_mapping_dcl. intros *. cbn.
          rewrite ?inst_subst, ?inst_lift. intros. subst.
          f_equal; auto. f_equal; auto.
        + unfold sout_mapping_dcl. intros *. cbn.
          rewrite ?inst_subst, ?inst_lift. intros. subst.
          f_equal; auto. f_equal; auto.
    Qed.

    Lemma dmut_wp_bind_right {AT A BT B} `{InstLaws AT A, InstLaws BT B} {Œì1 Œì2 Œì3 Œ£0 Œ£1}
          (d1 : DynamicMutator Œì1 Œì2 AT Œ£0) (d2 : DynamicMutator Œì2 Œì3 BT Œ£0) (d2_dcl : dmut_dcl d2)
          (Œ∂01 : Sub Œ£0 Œ£1) (pc1 : PathCondition Œ£1) (s1 : SymbolicState Œì1 Œ£1) (Œπ1 : SymInstance Œ£1)
          (P : B -> SCState Œì3 -> Prop) (Hpc1 : instpc Œπ1 pc1) :
      dmut_wp (dmut_bind_right d1 d2) Œ∂01 pc1 s1 Œπ1 P <->
      dmut_wp d1 Œ∂01 pc1 s1 Œπ1 (fun a sc2 => dmut_wp d2 Œ∂01 pc1 (lift sc2) Œπ1 P).
    Proof.
      unfold dmut_bind_right. rewrite dmut_wp_bind; auto.
      unfold dmut_wp, dmut_sub.
      split; apply sout_wp_monotonic;
        intros [a sc2]; now rewrite sub_comp_id_left.
      unfold dmut_arrow_dcl. intros until Q; intros PQ.
      rewrite ?dmut_wp_sub. eapply d2_dcl; eauto.
    Qed.

    Lemma dmut_bind_right_arrow_dcl {AT A BT B CT C} `{InstLaws AT A, InstLaws BT B, InstLaws CT C} {Œì1 Œì2 Œì3 Œ£1}
      (d1 : dmut_arrow Œì1 Œì2 AT BT Œ£1) (d1_dcl : dmut_arrow_dcl d1)
      (d2 : dmut_arrow Œì2 Œì3 AT CT Œ£1) (d2_dcl : dmut_arrow_dcl d2) :
      dmut_arrow_dcl (fun Œ£2 Œ∂02 a2 => dmut_bind_right (d1 Œ£2 Œ∂02 a2) (d2 Œ£2 Œ∂02 a2)).
    Proof.
      intros until Q. intros PQ.
      rewrite ?dmut_wp_bind_right; eauto.
      eapply d1_dcl; eauto. intros ? ?.
      eapply d2_dcl; eauto. now rewrite ?inst_lift.
      now apply dmut_arrow_dcl_specialize.
      now apply dmut_arrow_dcl_specialize.
    Qed.

    Lemma dmut_bind_arrow_dcl {AT A BT B CT C} `{InstLaws AT A, InstLaws BT B, InstLaws CT C}
        {Œì1 Œì2 Œì3 Œ£0}
        (d1 : dmut_arrow Œì1 Œì2 AT BT Œ£0) (d1_dcl : dmut_arrow_dcl d1)
        (d2 : dmut_arrow Œì2 Œì3 BT CT Œ£0) (d2_dcl : dmut_arrow_dcl d2) :
      dmut_arrow_dcl (fun Œ£2 Œ∂02 a2 => dmut_bind (d1 Œ£2 Œ∂02 a2) (fun Œ£3 Œ∂23 a3 => d2 Œ£3 (sub_comp Œ∂02 Œ∂23) a3)).
    Proof.
      unfold dmut_arrow_dcl, dmut_geq.
      intros * -> Hpc1 Hpc2 HŒ∂ Ha Hs P Q PQ; cbn.
      rewrite ?dmut_wp_bind; auto. eapply d1_dcl; eauto. intros a s.
      eapply d2_dcl; eauto; unfold sub_comp in *; rewrite ?inst_subst in HŒ∂;
        rewrite ?inst_subst, ?inst_lift, ?inst_sub_id; intuition.

      unfold dmut_arrow_dcl.
      intros * -> Hpc3 Hpc4 HŒ∂2 Ha2 Hs2 P2 Q2 PQ2; cbn.
      eapply d2_dcl; eauto.
      unfold sub_comp.
      unfold sub_comp in HŒ∂2.
      rewrite ?inst_subst in HŒ∂2.
      now rewrite ?inst_subst, HŒ∂2.

      unfold dmut_arrow_dcl.
      intros * -> Hpc3 Hpc4 HŒ∂2 Ha2 Hs2 P2 Q2 PQ2; cbn.
      eapply d2_dcl; eauto.
      unfold sub_comp.
      unfold sub_comp in HŒ∂2.
      rewrite ?inst_subst in HŒ∂2.
      now rewrite ?inst_subst, HŒ∂2.
    Qed.

    Lemma dmut_sub_arrow_dcl {AT A BT B} `{InstLaws AT A, InstLaws BT B} {Œì2 Œì3 Œ£0} (d : DynamicMutator Œì2 Œì3 BT Œ£0) (d_dcl : dmut_dcl d) :
      dmut_arrow_dcl (fun (Œ£2 : LCtx) (Œ∂02 : Sub Œ£0 Œ£2) (_ : AT Œ£2) => dmut_sub Œ∂02 d).
    Proof. intros until Q; intros PQ. rewrite ?dmut_wp_sub. eapply d_dcl; eauto. Qed.

    Lemma dmut_pure_arrow_dcl {AT A} `{InstLaws AT A} {Œì Œ£0} :
      dmut_arrow_dcl (fun Œ£1 (Œ∂01 : Sub Œ£0 Œ£1) (a1 : AT Œ£1) => dmut_pure (Œì := Œì) a1).
    Proof.
      intros until Q; intros PQ. cbn.
      intros HP. apply PQ. revert HP.
      rewrite ?inst_subst. intuition.
    Qed.

    Lemma dmut_wp_bind_left {AT A BT B} `{InstLaws AT A, InstLaws BT B} {Œì1 Œì2 Œì3 Œ£0 Œ£1}
          (d1 : DynamicMutator Œì1 Œì2 AT Œ£0) (d2 : DynamicMutator Œì2 Œì3 BT Œ£0) (d2_dcl : dmut_dcl d2)
          (Œ∂01 : Sub Œ£0 Œ£1) (pc1 : PathCondition Œ£1) (s1 : SymbolicState Œì1 Œ£1) (Œπ1 : SymInstance Œ£1)
          (P : A -> SCState Œì3 -> Prop) (Hpc1 : instpc Œπ1 pc1) :
      dmut_wp (dmut_bind_left d1 d2) Œ∂01 pc1 s1 Œπ1 P <->
      dmut_wp d1 Œ∂01 pc1 s1 Œπ1 (fun a sc2 => dmut_wp d2 Œ∂01 pc1 (lift sc2) Œπ1 (fun _ => P a)).
    Proof.
      unfold dmut_bind_left. rewrite dmut_wp_bind; auto. apply dmut_wp_equiv.
      intros a sc2. rewrite dmut_wp_bind_right, dmut_wp_sub; auto.
      split; eapply d2_dcl; unfold sub_comp; rewrite ?inst_subst, ?inst_sub_id; auto;
        intros _ sc3; now rewrite dmut_wp_pure, ?inst_lift.
      apply dmut_pure_dcl.
      apply dmut_bind_right_arrow_dcl.
      now apply dmut_sub_arrow_dcl.
      apply dmut_pure_arrow_dcl.
    Qed.

    Lemma dmut_wp_state {AT A} `{Inst AT A, Subst AT} {Œì1 Œì2 Œ£1 Œ£2} (f : forall Œ£2, Sub Œ£1 Œ£2 -> SymbolicState Œì1 Œ£2 -> Pair AT (SymbolicState Œì2) Œ£2)
          (pc2 : PathCondition Œ£2) (s12 : SymbolicState Œì1 Œ£2) (Œ∂12 : Sub Œ£1 Œ£2) (Œπ2 : SymInstance Œ£2) (Q : A -> SCState Œì2 -> Prop) :
      dmut_wp (dmut_state f) Œ∂12 pc2 s12 Œπ2 Q <->
      match f Œ£2 Œ∂12 s12 with | (a, s22) => Q (inst Œπ2 a) (inst Œπ2 s22) end.
    Proof.
      unfold dmut_wp, dmut_state; cbn.
      now destruct (f Œ£2 Œ∂12 s12).
    Qed.

    Lemma dmut_wp_demonic_binary {AT A} `{Inst AT A, Subst AT} {Œì1 Œì2 Œ£0 Œ£1} (d1 d2 : DynamicMutator Œì1 Œì2 AT Œ£0)
          (Œ∂01 : Sub Œ£0 Œ£1) (pc1 : PathCondition Œ£1) (s11 : SymbolicState Œì1 Œ£1) (Œπ1 : SymInstance Œ£1)
          (P : A -> SCState Œì2 -> Prop) :
      dmut_wp (dmut_demonic_binary d1 d2) Œ∂01 pc1 s11 Œπ1 P <->
      dmut_wp d1 Œ∂01 pc1 s11 Œπ1 P /\ dmut_wp d2 Œ∂01 pc1 s11 Œπ1 P.
    Proof. reflexivity. Qed.

    Lemma dmut_wp_angelic_binary {AT A} `{Inst AT A, Subst AT} {Œì1 Œì2 Œ£0 Œ£1} (d1 d2 : DynamicMutator Œì1 Œì2 AT Œ£0)
      (Œ∂01 : Sub Œ£0 Œ£1) (pc1 : PathCondition Œ£1) (s11 : SymbolicState Œì1 Œ£1) (Œπ1 : SymInstance Œ£1) (P : A -> SCState Œì2 -> Prop) :
      dmut_wp (dmut_angelic_binary d1 d2) Œ∂01 pc1 s11 Œπ1 P <->
      dmut_wp d1 Œ∂01 pc1 s11 Œπ1 P \/ dmut_wp d2 Œ∂01 pc1 s11 Œπ1 P.
    Proof. reflexivity. Qed.

    Lemma dmut_wp_angelic {AT A I} `{Inst AT A, Subst AT} {Œì1 Œì2 Œ£ Œ£1} (d : I -> DynamicMutator Œì1 Œì2 AT Œ£) (* (d_dcl : dmut_dcl d) *)
      (Œ∂01 : Sub Œ£ Œ£1) (pc1 : PathCondition Œ£1) (s1 : SymbolicState Œì1 Œ£1) (Œπ1 : SymInstance Œ£1)
      (P : A -> SCState Œì2 -> Prop) :
      dmut_wp (dmut_angelic d) Œ∂01 pc1 s1 Œπ1 P <->
      exists i, dmut_wp (d i) Œ∂01 pc1 s1 Œπ1 P.
    Proof. reflexivity. Qed.

    Lemma dmut_wp_fresh {AT A} `{Inst AT A, Subst AT} {Œì1 Œì2 Œ£ Œ£1 x œÉ} (d : DynamicMutator Œì1 Œì2 AT (Œ£ ‚ñª (x :: œÉ))) (d_dcl : dmut_dcl d)
          (Œ∂01 : Sub Œ£ Œ£1) (pc1 : PathCondition Œ£1) (s1 : SymbolicState Œì1 Œ£1) (Œπ1 : SymInstance Œ£1)
          (P : A -> SCState Œì2 -> Prop) (hpc : instpc Œπ1 pc1) :
      dmut_wp (dmut_fresh x œÉ d) Œ∂01 pc1 s1 Œπ1 P <->
      forall v : Lit œÉ, dmut_wp d (sub_snoc Œ∂01 (x :: œÉ) (term_lit œÉ v)) pc1 s1 Œπ1 P.
    Proof.
      unfold dmut_wp, dmut_fresh; cbn.
      split; intros Hwp v; specialize (Hwp v); revert Hwp.
      - apply (d_dcl
                 (Œ£1 ‚ñª (fresh Œ£1 (Some x) :: œÉ)) Œ£1 (sub_snoc (sub_comp Œ∂01 sub_wk1) (x :: œÉ) (term_var (fresh Œ£1 (Some x)))) (subst sub_wk1 pc1)
                 (subst sub_wk1 s1) (sub_snoc (sub_id Œ£1) (fresh Œ£1 (Some x) :: œÉ) (term_lit œÉ v)) pc1 s1 (sub_snoc Œ∂01 (x :: œÉ) (term_lit œÉ v)));
          rewrite ?inst_subst, ?inst_sub_snoc, ?inst_sub_wk1, ?inst_sub_id; auto; cbn.
        unfold sub_comp. now rewrite inst_subst, inst_sub_wk1.
      - apply (d_dcl
                 Œ£1 (Œ£1 ‚ñª (fresh Œ£1 (Some x) :: œÉ)) (sub_snoc Œ∂01 (x :: œÉ) (term_lit œÉ v)) pc1 s1 sub_wk1 (subst sub_wk1 pc1) (subst sub_wk1 s1)
                 (sub_snoc (sub_comp Œ∂01 sub_wk1) (x :: œÉ) (term_var (fresh Œ£1 (Some x)))));
          rewrite ?inst_subst, ?inst_sub_snoc, ?inst_sub_wk1, ?inst_sub_id; auto; cbn.
        unfold sub_comp. now rewrite inst_subst, inst_sub_wk1.
    Qed.

    Lemma dmut_wp_angelic_list {AT A D} `{InstLaws AT A} {Œì Œ£} (func msg : string) (data : D)
      (xs : List AT Œ£) Œ£1 (Œ∂01 : Sub Œ£ Œ£1) (pc1 : PathCondition Œ£1) (s11 : SymbolicState Œì Œ£1) (Œπ1 : SymInstance Œ£1)
      (P : A -> SCState Œì -> Prop) :
      dmut_wp (dmut_angelic_list func msg data xs) Œ∂01 pc1 s11 Œπ1 P <->
      exists x : AT _, List.In x xs /\ P (inst (inst Œπ1 Œ∂01) x) (inst Œπ1 s11).
    Proof.
      induction xs; cbn - [dmut_wp].
      - rewrite dmut_wp_fail. split. intro Fm; exfalso; intuition.
        intros []; intuition.
      - destruct xs; cbn - [dmut_wp] in *.
        + rewrite dmut_wp_fail in IHxs.
          rewrite dmut_wp_pure.
          destruct IHxs. split; intros; destruct_conjs.
          exists a. intuition.
          intuition.
        + rewrite dmut_wp_angelic_binary, dmut_wp_pure.
          split. intros [Hwp|Hwp].
          * exists a. split; auto.
          * apply IHxs in Hwp. destruct Hwp as [x [Hwp HP]].
            exists x. split; auto.
          * intros [x [Hwp HP]].
            destruct Hwp as [Hwp|Hwp]. subst. left. auto.
            destruct Hwp as [Hwp|Hwp]. subst.
            right. apply IHxs. exists x. split; auto.
            right. apply IHxs. exists x. split; auto.
    Qed.

    Lemma dmut_wp_demonic_list {AT A} `{InstLaws AT A} {Œì Œ£}
      (xs : List AT Œ£) Œ£1 (Œ∂01 : Sub Œ£ Œ£1) (pc1 : PathCondition Œ£1) (s11 : SymbolicState Œì Œ£1) (Œπ1 : SymInstance Œ£1)
      (P : A -> SCState Œì -> Prop) :
      dmut_wp (dmut_demonic_list xs) Œ∂01 pc1 s11 Œπ1 P <->
      forall x : AT _, List.In x xs -> P (inst (inst Œπ1 Œ∂01) x) (inst Œπ1 s11).
    Proof.
      induction xs.
      - cbn; firstorder.
      - destruct xs; cbn; rewrite inst_subst; intuition.
    Qed.

    Lemma dmut_wp_demonic_finite {X AT A} `{finite.Finite X, Subst AT, Inst AT A, InstLaws AT A, SubstLaws AT} {Œì1 Œì2 Œ£ Œ£1}
      (k : X -> DynamicMutator Œì1 Œì2 AT Œ£) (k_dcl : forall x, dmut_dcl (k x))
      (Œ∂01 : Sub Œ£ Œ£1) (pc1 : PathCondition Œ£1) (s1 : SymbolicState Œì1 Œ£1) (Œπ1 : SymInstance Œ£1)
      (P : A -> SCState Œì2 -> Prop) (Hpc : instpc Œπ1 pc1) :
      dmut_wp (dmut_demonic_finite X k) Œ∂01 pc1 s1 Œπ1 P <->
      (forall x : X, dmut_wp (k x) Œ∂01 pc1 s1 Œπ1 P).
    Proof.
      unfold dmut_demonic_finite.
      rewrite dmut_wp_bind.
      - rewrite dmut_wp_demonic_list.
        setoid_rewrite dmut_wp_sub.
        setoid_rewrite sub_comp_id_left.
        setoid_rewrite <-base.elem_of_list_In.
        split.
        + intros Hk x.
          specialize (Hk x).
          specialize (Hk (finite.elem_of_enum x)).
          revert Hk.
          eapply k_dcl; erewrite ?inst_sub_id, ?inst_lift; trivial.
        + intros Hk x _.
          specialize (Hk x).
          revert Hk.
          eapply k_dcl; erewrite ?inst_sub_id, ?inst_lift; trivial.
      - intros until Q; intros PQ. rewrite ?dmut_wp_sub.
        unfold instantiate_const, inst in H12; subst.
        eapply k_dcl; eauto.
      - eauto.
    Qed.

    Lemma dmut_wp_freshtermvar {Œì Œ£ Œ£1 x œÉ}
      (Œ∂01 : Sub Œ£ Œ£1) (pc1 : PathCondition Œ£1) (s1 : SymbolicState Œì Œ£1) (Œπ1 : SymInstance Œ£1)
      (P : Lit œÉ -> SCState Œì -> Prop) (Hpc : instpc Œπ1 pc1) :
      dmut_wp (@dmut_freshtermvar Œì _ œÉ x) Œ∂01 pc1 s1 Œπ1 P <->
      forall v : Lit œÉ, P v (inst Œπ1 s1).
    Proof.
      unfold dmut_freshtermvar. rewrite dmut_wp_fresh; auto.
      apply dmut_pure_dcl.
    Qed.

    Lemma dmut_fail_dcl `{Inst AT A, Subst AT} {D Œì1 Œì2 Œ£} func msg data :
      dmut_dcl (@dmut_fail Œì1 Œì2 AT Œ£ D func msg data).
    Proof.
      unfold dmut_dcl, dmut_geq. intros * -> Hpc1 Hpc2 Hs HŒ∂ * PQ.
      now rewrite ?dmut_wp_fail.
    Qed.

    Lemma dmut_sub_dcl {Œì1 Œì2 AT A Œ£0} `{Inst AT A, Subst AT} (d : DynamicMutator Œì1 Œì2 AT Œ£0) (d_dcl : dmut_dcl d) :
      forall (Œ£1 : LCtx) (Œ∂1 : Sub Œ£0 Œ£1), dmut_dcl (dmut_sub Œ∂1 d).
    Proof.
      unfold dmut_dcl, dmut_geq. intros * -> Hpc1 Hpc2 Hs HŒ∂ * PQ. rewrite ?dmut_wp_sub.
      apply d_dcl with Œ∂12; auto. unfold sub_comp. rewrite ?inst_subst. congruence.
    Qed.

    Lemma dmut_fresh_dcl {AT A} `{Inst AT A, Subst AT} {Œì1 Œì2 Œ£ x œÉ} (d : DynamicMutator Œì1 Œì2 AT (Œ£ ‚ñª (x :: œÉ))) (d_dcl : dmut_dcl d) :
      dmut_dcl (dmut_fresh x œÉ d).
    Proof.
      unfold dmut_dcl, dmut_geq. intros until Q; intros PQ.
      rewrite ?dmut_wp_fresh; auto.
      intros Hwp v. specialize (Hwp v). revert Hwp.
      eapply d_dcl; eauto. rewrite ?inst_sub_snoc.
      cbn. f_equal. exact H5.
    Qed.

    Lemma dmut_freshtermvar_dcl {Œì Œ£ x œÉ} :
      dmut_dcl (@dmut_freshtermvar Œì Œ£ œÉ x).
    Proof. apply dmut_fresh_dcl, dmut_pure_dcl. Qed.

    Ltac fold_inst_term :=
      repeat change (@inst_term ?Œ£ ?Œπ ?œÉ ?t) with (@inst (fun Œ£ => Term Œ£ œÉ) (Lit œÉ) (@instantiate_term œÉ) Œ£ Œπ t) in *.

    Lemma dmut_bind_dcl {AT A BT B} `{InstLaws AT A, InstLaws BT B}
        {Œì1 Œì2 Œì3 Œ£0} (d : DynamicMutator Œì1 Œì2 AT Œ£0) (d_dcl : dmut_dcl d)
        (f : dmut_arrow Œì2 Œì3 AT BT Œ£0) (f_dcl : dmut_arrow_dcl f) :
      dmut_dcl (dmut_bind d f).
    Proof.
      unfold dmut_dcl, dmut_geq. intros * -> Hpc1 Hpc2 Hs HŒ∂ P Q PQ; cbn.
      rewrite ?dmut_wp_bind; auto. eapply d_dcl; eauto. intros a s.
      eapply f_dcl; eauto; unfold sub_comp;
        rewrite ?inst_subst, ?inst_lift, ?inst_sub_id; intuition.
    Qed.

    Lemma dmut_bind_right_dcl `{InstLaws AT A, InstLaws BT B} {Œì1 Œì2 Œì3 Œ£0}
      (d1 : DynamicMutator Œì1 Œì2 AT Œ£0) (d2 : DynamicMutator Œì2 Œì3 BT Œ£0)
      (d1_dcl : dmut_dcl d1) (d2_dcl : dmut_dcl d2) :
      dmut_dcl (dmut_bind_right d1 d2).
    Proof.
      unfold dmut_bind_right, dmut_sub. apply dmut_bind_dcl; auto.
      unfold dmut_arrow_dcl. intros. revert H13. eapply d2_dcl; eauto.
    Qed.

    Lemma dmut_bind_left_dcl `{InstLaws AT A, InstLaws BT B} {Œì1 Œì2 Œì3 Œ£0}
      (d1 : DynamicMutator Œì1 Œì2 AT Œ£0) (d2 : DynamicMutator Œì2 Œì3 BT Œ£0)
      (d1_dcl : dmut_dcl d1) (d2_dcl : dmut_dcl d2) :
      dmut_dcl (dmut_bind_left d1 d2).
    Proof.
      unfold dmut_bind_left. apply dmut_bind_dcl; auto.
      apply dmut_bind_right_arrow_dcl.
      now apply dmut_sub_arrow_dcl.
      apply dmut_pure_arrow_dcl.
    Qed.

    Lemma dmut_demonic_binary_dcl {Œì1 Œì2 AT A Œ£0} `{Inst AT A, Subst AT} (d1 d2 : DynamicMutator Œì1 Œì2 AT Œ£0) (d1_dcl : dmut_dcl d1) (d2_dcl : dmut_dcl d2) :
      dmut_dcl (dmut_demonic_binary d1 d2).
    Proof.
      unfold dmut_dcl, dmut_geq. intros until Q; intros PQ.
      rewrite ?dmut_wp_demonic_binary. intros [Hwp1 Hwp2].
      split.
      - revert Hwp1. eapply d1_dcl; eauto.
      - revert Hwp2. eapply d2_dcl; eauto.
    Qed.

    Lemma dmut_angelic_binary_dcl {Œì1 Œì2 AT A Œ£0} `{Inst AT A, Subst AT} (d1 d2 : DynamicMutator Œì1 Œì2 AT Œ£0) (d1_dcl : dmut_dcl d1) (d2_dcl : dmut_dcl d2) :
      dmut_dcl (dmut_angelic_binary d1 d2).
    Proof.
      unfold dmut_dcl, dmut_geq. intros until Q; intros PQ.
      rewrite ?dmut_wp_angelic_binary. intros [Hwp1|Hwp2].
      - left. revert Hwp1. eapply d1_dcl; eauto.
      - right. revert Hwp2. eapply d2_dcl; eauto.
    Qed.

    Lemma dmut_state_dcl {AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£}
          (f : forall Œ£' : LCtx, Sub Œ£ Œ£' -> SymbolicState Œì1 Œ£' -> Pair AT (SymbolicState Œì2) Œ£')
          (f_dcl : forall Œ£1 Œ£2 (Œ∂01 : Sub Œ£ Œ£1) (Œ∂02 : Sub Œ£ Œ£2) (Œ∂12 : Sub Œ£1 Œ£2) (s1 : SymbolicState Œì1 Œ£1) (s2 : SymbolicState Œì1 Œ£2) Œπ1 Œπ2,
              Œπ1 = inst Œπ2 Œ∂12 ->
              inst Œπ1 s1 = inst Œπ2 s2 ->
              inst Œπ1 Œ∂01 = inst Œπ2 Œ∂02 ->
              inst Œπ1 (f Œ£1 Œ∂01 s1) = inst Œπ2 (f Œ£2 Œ∂02 s2)) :
      dmut_dcl (dmut_state f).
    Proof.
      unfold dmut_dcl; intros until Q. intros PQ. rewrite ?dmut_wp_state.
      pose proof (f_dcl Œ£1 Œ£2 Œ∂01 Œ∂02 Œ∂12 s1 s2 Œπ1 Œπ2) as Hf.
      inster Hf by auto. destruct (f Œ£1 Œ∂01 s1), (f Œ£2 Œ∂02 s2); cbn.
      inversion Hf. intros Hp. apply PQ. revert Hp. intuition.
    Qed.
    Local Hint Resolve dmut_state_dcl : core.

    Lemma dmut_put_heap_dcl {Œì Œ£} (h : SymbolicHeap Œ£) :
      dmut_dcl (dmut_put_heap (Œì := Œì) h).
    Proof.
      apply dmut_state_dcl. destruct s1 as [Œ¥ h1], s2 as [Œ¥2 h2].
      cbn. intros ? ? -> Heqs HeqŒ∂. inversion Heqs.
      f_equal. f_equal. rewrite ?inst_subst. intuition.
    Qed.
    Local Hint Resolve dmut_put_heap_dcl : core.

    Lemma dmut_pop_local_dcl {Œì x œÉ Œ£} :
      dmut_dcl (@dmut_pop_local Œì x œÉ Œ£).
    Proof.
      unfold dmut_pop_local, dmut_modify_local, dmut_state_local.
      apply dmut_state_dcl. destruct s1 as [Œ¥1 h1], s2 as [Œ¥2 h2]; cbn.
      intros * -> Hs HŒ∂. inversion Hs. clear Hs.
      destruct (snocView Œ¥1), (snocView Œ¥2). cbn in H0.
      apply noConfusion_inv, (f_equal pr1) in H0. cbn in H0.
      f_equal. f_equal. cbn. apply H0.
    Qed.

    Lemma dmut_block_dcl {AT A} `{Subst AT, Inst AT A} {Œì1 Œì2 Œ£}  :
      dmut_dcl (Œì1 := Œì1) (Œì2 := Œì2) (Œ£0 := Œ£) dmut_block.
    Proof. now unfold dmut_dcl, dmut_block. Qed.

    (* Lemma dmut_demonic_list_dcl {AT A} `{Subst AT, Inst AT A} {Œì1 Œì2 Œ£} (l : list (DynamicMutator Œì1 Œì2 AT Œ£)) *)
    (*   (l_dcl : forall d, List.In d l -> dmut_dcl d) : *)
    (*   dmut_dcl (dmut_demonic_list l). *)
    (* Proof. *)
    (*   induction l; cbn. *)
    (*   - apply dmut_block_dcl. *)
    (*   - destruct l. *)
    (*     + apply l_dcl. now left. *)
    (*     + apply dmut_demonic_binary_dcl. *)
    (*       apply l_dcl. now left. *)
    (*       apply IHl. intros d' dIn'. *)
    (*       apply l_dcl. now right. *)
    (* Qed. *)

    Lemma dmut_angelic_list_dcl {AT A D} `{Subst AT, SubstLaws AT, Inst AT A, InstLaws AT A}
          {Œì Œ£} func msg (data : D) (l : list (AT Œ£)) :
      dmut_dcl (Œì2 := Œì) (dmut_angelic_list func msg data l).
    Proof.
      induction l; cbn.
      - apply dmut_fail_dcl.
      - destruct l.
        + apply dmut_pure_dcl.
        + apply dmut_angelic_binary_dcl.
          apply dmut_pure_dcl.
          apply IHl.
    Qed.

    Lemma dmut_angelic_list_arrow_dcl {AT A BT B D} `{Subst AT, SubstLaws AT, Inst AT A, InstLaws AT A, Inst BT B, InstLaws BT B}
          {Œì Œ£} func msg (data : D) (l : forall Œ£2 (Œ∂ : Sub Œ£ Œ£2) s, list (BT Œ£2))
      (Hl : forall (Œ£1 Œ£2 : LCtx) (Œ∂01 : Sub Œ£ Œ£1) (Œ∂02 : Sub Œ£ Œ£2) (a1 : AT Œ£1) (a2 : AT Œ£2) (Œ£3 Œ£4 : LCtx)
         (Œ∂13 : Sub Œ£1 Œ£3) (Œ∂24 : Sub Œ£2 Œ£4) (Œ∂34 : Sub Œ£3 Œ£4) (pc3 : PathCondition Œ£3) (pc4 : PathCondition Œ£4)
         (Œπ3 : SymInstance Œ£3) (Œπ4 : SymInstance Œ£4),
          Œπ3 = inst Œπ4 Œ∂34 ->
          instpc Œπ3 pc3 ->
          instpc Œπ4 pc4 ->
          inst Œπ3 (sub_comp Œ∂01 Œ∂13) = inst Œπ4 (sub_comp Œ∂02 Œ∂24) ->
          inst (inst Œπ3 Œ∂13) a1 = inst (inst Œπ4 Œ∂24) a2 ->
          inst (inst Œπ3 Œ∂13) (l Œ£1 Œ∂01 a1) = inst (inst Œπ4 Œ∂24) (l Œ£2 Œ∂02 a2)) :
      dmut_arrow_dcl (Œì2 := Œì) (fun Œ£2 (Œ∂ : Sub Œ£ Œ£2) s => dmut_angelic_list func msg data (l Œ£2 Œ∂ s)).
    Proof.
      unfold dmut_arrow_dcl.
      intros until Q.
      intros PQ.
      assert (eql : inst (inst Œπ3 Œ∂13) (l Œ£1 Œ∂01 a1) = inst (inst Œπ4 Œ∂24) (l Œ£2 Œ∂02 a2)) by (eapply Hl; eauto).
      rewrite ?dmut_wp_angelic_list; eauto.
      intros (x & xInl1 & Px).
      apply (List.in_map (inst (inst Œπ3 Œ∂13))) in xInl1.
      unfold inst at 1 3 in eql; cbn in eql.
      rewrite eql in xInl1.
      eapply List.in_map_iff in xInl1.
      destruct xInl1 as (x2 & eq2 & x2Inl2).
      apply PQ in Px.
      rewrite <-eq2,H17 in Px.
      exists x2; eauto.
    Qed.

    (* Lemma dmut_demonic_finite_dcl {F AT A} `{finite.Finite F, Subst AT, Inst AT A} {Œì Œ£} *)
    (*   (k : F -> DynamicMutator Œì Œì AT Œ£) (k_dcl : forall x, dmut_dcl (k x)) : *)
    (*   dmut_dcl (dmut_demonic_finite F k). *)
    (* Proof. *)
    (*   unfold dmut_demonic_finite. apply dmut_demonic_list_dcl. *)
    (*   intros d. rewrite List.in_map_iff. *)
    (*   intros [x [? xIn]]. subst d. apply k_dcl. *)
    (* Qed. *)

    (* Lemma dmut_angelic_finite_dcl {F AT A} `{finite.Finite F, Subst AT, Inst AT A} {Œì Œ£} *)
    (*   (k : F -> DynamicMutator Œì Œì AT Œ£) (k_dcl : forall x, dmut_dcl (k x)) : *)
    (*   dmut_dcl (dmut_angelic_finite F k). *)
    (* Proof. *)
    (*   unfold dmut_angelic_finite. apply dmut_angelic_list_dcl. *)
    (*   intros d. rewrite List.in_map_iff. *)
    (*   intros [x [? xIn]]. subst d. apply k_dcl. *)
    (* Qed. *)

    Lemma dmut_wp_assume_formula {Œì Œ£1 Œ£2} (Œ∂12 : Sub Œ£1 Œ£2) (pc2 : PathCondition Œ£2) (fml : Formula Œ£1) (s2 : SymbolicState Œì Œ£2)
          (Œπ2 : SymInstance Œ£2) P :
      instpc Œπ2 pc2 ->
      dmut_wp (dmut_assume_formula fml) Œ∂12 pc2 s2 Œπ2 P <->
      ((inst (inst Œπ2 Œ∂12) fml : Prop) -> P tt (inst Œπ2 s2)).
    Proof.
      unfold dmut_wp, dmut_assume_formula. intros.
      rewrite sout_wp_bind; auto.
      - rewrite sout_wp_assume_formula.
        rewrite ?subst_sub_id, ?inst_subst.
        reflexivity.
      - unfold sout_arrow_dcl. cbn. intros.
        revert H5. rewrite ?inst_subst.
        rewrite H3, H4. apply PQ.
    Qed.

    Lemma dmut_assume_formula_dcl {Œì Œ£} (fml : Formula Œ£) :
      dmut_dcl (Œì1 := Œì) (dmut_assume_formula fml).
    Proof.
      unfold dmut_dcl, dmut_geq; intros. revert H4.
      rewrite ?dmut_wp_assume_formula; auto.
      rewrite H2, H3. intuition.
    Qed.

    Lemma dmut_assume_formulas_dcl {Œì Œ£} (fmls : list (Formula Œ£)) :
      dmut_dcl (Œì1 := Œì) (dmut_assume_formulas fmls).
    Proof.
      induction fmls.
      + now eapply dmut_pure_dcl.
      + cbn.
        eapply dmut_bind_right_dcl.
        eapply dmut_assume_formula_dcl.
        eapply IHfmls.
    Qed.

    Lemma dmut_wp_assume_formulas {Œì Œ£1 Œ£2} (Œ∂12 : Sub Œ£1 Œ£2) (pc2 : PathCondition Œ£2) (fmls : list (Formula Œ£1)) (s2 : SymbolicState Œì Œ£2)
      (Œπ2 : SymInstance Œ£2) (Hpc2 : instpc Œπ2 pc2) P :
      dmut_wp (dmut_assume_formulas fmls) Œ∂12 pc2 s2 Œπ2 P <->
      (instpc (inst Œπ2 Œ∂12) fmls -> P tt (inst Œπ2 s2)).
    Proof.
      unfold dmut_assume_formulas. revert s2.
      induction fmls; cbn [List.fold_right]; intros s2.
      - rewrite dmut_wp_pure. cbn. intuition.
        apply H. constructor.
      - rewrite dmut_wp_bind_right; auto.
        rewrite dmut_wp_assume_formula; auto.
        rewrite IHfmls.
        rewrite inst_pathcondition_cons.
        rewrite inst_lift.
        intuition.
        eapply dmut_assume_formulas_dcl.
    Qed.

    Lemma dmut_wp_assert_formula {Œì Œ£1 Œ£2} (Œ∂12 : Sub Œ£1 Œ£2) (pc2 : PathCondition Œ£2) (fml : Formula Œ£1) (s2 : SymbolicState Œì Œ£2)
      (Œπ2 : SymInstance Œ£2) (Hpc2 : instpc Œπ2 pc2) P :
      dmut_wp (dmut_assert_formula fml) Œ∂12 pc2 s2 Œπ2 P <->
      (inst (inst Œπ2 Œ∂12) fml /\ P tt (inst Œπ2 s2)).
    Proof.
      unfold dmut_wp, dmut_assert_formula.
      rewrite sout_wp_bind, sout_wp_assert_formula; cbn;
        rewrite ?inst_subst, ?inst_sub_id; auto.
      unfold sout_arrow_dcl. cbn. intros.
      revert H4. rewrite ?inst_subst.
      rewrite H2, H3. apply PQ.
    Qed.

    Lemma dmut_assert_formula_dcl {Œì Œ£} (fml : Formula Œ£) :
      dmut_dcl (Œì1 := Œì) (dmut_assert_formula fml).
    Proof.
      unfold dmut_dcl, dmut_geq. intros. revert H4.
      rewrite ?dmut_wp_assert_formula; auto.
      rewrite H2, H3. intuition.
    Qed.

    Lemma dmut_dcl_assert_formulas {Œì Œ£} (fmls : list (Formula Œ£)) :
      dmut_dcl (dmut_assert_formulas (Œì := Œì) fmls).
    Proof.
      induction fmls; cbn; [eapply dmut_pure_dcl|].
      eapply dmut_bind_right_dcl.
      eapply dmut_assert_formula_dcl.
      eapply IHfmls.
    Qed.

    Lemma dmut_wp_assert_formulas {Œì Œ£1 Œ£2} (Œ∂12 : Sub Œ£1 Œ£2) (pc2 : PathCondition Œ£2) (fmls : list (Formula Œ£1)) (s2 : SymbolicState Œì Œ£2)
      (Œπ2 : SymInstance Œ£2) (Hpc2 : instpc Œπ2 pc2) P :
      dmut_wp (dmut_assert_formulas fmls) Œ∂12 pc2 s2 Œπ2 P <->
      (instpc (inst Œπ2 Œ∂12) fmls /\ P tt (inst Œπ2 s2)).
    Proof.
      unfold dmut_assert_formulas. revert s2.
      induction fmls; cbn [List.fold_right]; intros s2.
      - rewrite dmut_wp_pure. intuition.
        constructor.
      - rewrite dmut_wp_bind_right; auto.
        rewrite dmut_wp_assert_formula; auto.
        rewrite IHfmls.
        rewrite inst_pathcondition_cons.
        rewrite inst_lift.
        intuition.
        fold (dmut_assert_formulas (Œì := Œì) fmls).
        eapply dmut_dcl_assert_formulas.
    Qed.

    Lemma dmut_wp_match_enum {AT A E} `{InstLaws AT A} {Œì1 Œì2 Œ£1} (t : Term Œ£1 (ty_enum E))
      (d : ùë¨ùë≤ E -> DynamicMutator Œì1 Œì2 AT Œ£1) (d_dcl : forall x, dmut_dcl (d x))
      Œ£2 (Œ∂12 : Sub Œ£1 Œ£2) pc2 s2 Œπ2 P :
      instpc Œπ2 pc2 ->
      dmut_wp (dmut_match_enum t d) Œ∂12 pc2 s2 Œπ2 P <->
      dmut_wp (d (inst (T := fun Œ£ => Term Œ£ _) (A := ùë¨ùë≤ E) (inst Œπ2 Œ∂12) t)) Œ∂12 pc2 s2 Œπ2 P.
    Proof.
      intros Hpc2. unfold dmut_match_enum. cbn.
      destruct (term_get_lit_spec (subst (T := fun Œ£ => Term Œ£ (ty_enum E)) Œ∂12 t)) as [k HeqŒπs|]; cbn [Lit] in *.
      - fold_dmut_wp. specialize (HeqŒπs Œπ2). rewrite inst_subst in HeqŒπs. now rewrite HeqŒπs.
      - fold_dmut_wp. rewrite dmut_wp_demonic_finite. split; intros Hwp.
        + specialize (Hwp (inst (T := fun Œ£ => Term Œ£ _) (inst Œπ2 Œ∂12) t)).
          rewrite dmut_wp_bind_right, dmut_wp_assume_formula, dmut_wp_sub in Hwp; auto.
          rewrite sub_comp_id_right, inst_sub_id in Hwp. cbn in Hwp.
          inster Hwp by now rewrite inst_subst. revert Hwp.
          eapply d_dcl; rewrite ?inst_sub_id, ?inst_lift; eauto.
          now apply dmut_sub_dcl.
        + intros x. rewrite dmut_wp_bind_right; auto.
          rewrite dmut_wp_assume_formula; auto. cbn.
          rewrite inst_subst, inst_sub_id. intros <-.
          rewrite dmut_wp_sub. rewrite sub_comp_id_right. revert Hwp.
          eapply d_dcl; rewrite ?inst_sub_id, ?inst_lift; eauto.
          now apply dmut_sub_dcl.
        + intros x.
          apply dmut_bind_right_dcl.
          apply dmut_assume_formula_dcl.
          now apply dmut_sub_dcl.
        + assumption.
    Qed.

    Lemma dmut_wp_match_sum {AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£1} (x y : ùë∫) (œÉ œÑ : Ty) (s : Term Œ£1 (ty_sum œÉ œÑ))
      (dinl : DynamicMutator Œì1 Œì2 AT (Œ£1 ‚ñª (x :: œÉ)))  (dinl_dcl : dmut_dcl dinl)
      (dinr : DynamicMutator Œì1 Œì2 AT (Œ£1 ‚ñª (y :: œÑ)))  (dinr_dcl : dmut_dcl dinr)
      Œ£2 (Œ∂12 : Sub Œ£1 Œ£2) pc2 s2 Œπ2 P :
      instpc Œπ2 pc2 ->
      dmut_wp (dmut_match_sum s dinl dinr) Œ∂12 pc2 s2 Œπ2 P <->
      (forall sl,
          inst (T := fun Œ£ => Term Œ£ _) (A := Lit œÉ + Lit œÑ) (inst Œπ2 Œ∂12) s =
          @inl (Lit œÉ) (Lit œÑ) (inst (T := fun Œ£ => Term Œ£ _) (A := Lit œÉ) Œπ2 sl) ->
          dmut_wp dinl (sub_snoc Œ∂12 (x :: œÉ) sl) pc2 s2 Œπ2 P) /\
      (forall sr,
          inst (T := fun Œ£ => Term Œ£ (ty_sum œÉ œÑ)) (A := Lit œÉ + Lit œÑ) (inst Œπ2 Œ∂12) s =
          @inr (Lit œÉ) (Lit œÑ) (inst (T := fun Œ£ => Term Œ£ œÑ) (A := Lit œÑ) Œπ2 sr) ->
          dmut_wp dinr (sub_snoc Œ∂12 (y :: œÑ) sr) pc2 s2 Œπ2 P).
    Proof.
      intros Hpc2. unfold dmut_match_sum. cbn.
      destruct (term_get_sum_spec (subst (T := fun Œ£ => Term Œ£ (ty_sum œÉ œÑ)) Œ∂12 s)) as [[sl|sr] HeqŒπs|_].
      - fold_dmut_wp. specialize (HeqŒπs Œπ2). rewrite inst_subst in HeqŒπs. split.
        + intros Hwp. split.
          * intros sl' Heq. revert Hwp. rewrite HeqŒπs in Heq. inversion Heq.
            eapply dinl_dcl; unfold sub_comp;
              rewrite ?inst_subst, ?inst_sub_id, ?inst_sub_snoc; eauto.
            now f_equal.
          * intros sr Heq. rewrite HeqŒπs in Heq. discriminate.
        + intros [Hl Hr]. specialize (Hl sl HeqŒπs). revert Hl. auto.
      - fold_dmut_wp. specialize (HeqŒπs Œπ2). rewrite inst_subst in HeqŒπs. split.
        + intros Hwp. split.
          * intros sl Heq. rewrite HeqŒπs in Heq. discriminate.
          * intros sr' Heq. revert Hwp. rewrite HeqŒπs in Heq. inversion Heq.
            eapply dinr_dcl; unfold sub_comp;
              rewrite ?inst_subst, ?inst_sub_id, ?inst_sub_snoc; eauto.
            now f_equal.
        + intros [Hl Hr]. specialize (Hr sr HeqŒπs). revert Hr.
          eapply dinr_dcl; unfold sub_comp;
            rewrite ?inst_subst, ?inst_sub_id, ?inst_lift; eauto.
      - fold_dmut_wp. rewrite dmut_wp_demonic_binary.
        rewrite ?dmut_wp_fresh; auto.
        { split; intros [Hl Hr]; (split; [clear Hr|clear Hl]).
          - intros sl Heqsl. specialize (Hl (inst Œπ2 sl)).
            rewrite dmut_wp_bind_right, dmut_wp_assume_formula in Hl; auto.
            rewrite inst_sub_snoc in Hl. cbn in Hl.
            rewrite inst_subst, inst_sub_wk1 in Hl.
            specialize (Hl Heqsl). revert Hl.
            eapply dinl_dcl; unfold sub_comp; rewrite ?inst_subst, ?inst_sub_snoc, ?inst_sub_id, ?inst_lift; auto.
          - intros sr Heqsr. specialize (Hr (inst Œπ2 sr)).
            rewrite dmut_wp_bind_right, dmut_wp_assume_formula in Hr; auto.
            rewrite inst_sub_snoc in Hr. cbn in Hr.
            rewrite inst_subst, inst_sub_wk1 in Hr.
            specialize (Hr Heqsr). revert Hr.
            eapply dinr_dcl; unfold sub_comp; rewrite ?inst_subst, ?inst_sub_snoc, ?inst_sub_id, ?inst_lift; auto.
          - intros vl. specialize (Hl (term_lit _ vl)).
            rewrite dmut_wp_bind_right, dmut_wp_assume_formula; auto.
            rewrite inst_sub_snoc. cbn. rewrite inst_subst, inst_sub_wk1.
            intros Heq. specialize (Hl Heq). revert Hl.
            eapply dinl_dcl; unfold sub_comp; rewrite ?inst_subst, ?inst_sub_snoc, ?inst_sub_id, ?inst_lift; auto.
          - intros vr. specialize (Hr (term_lit _ vr)).
            rewrite dmut_wp_bind_right, dmut_wp_assume_formula; auto.
            rewrite inst_sub_snoc. cbn. rewrite inst_subst, inst_sub_wk1.
            intros Heq. specialize (Hr Heq). revert Hr.
            eapply dinr_dcl; unfold sub_comp; rewrite ?inst_subst, ?inst_sub_snoc, ?inst_sub_id, ?inst_lift; auto.
        }
        + apply dmut_bind_right_dcl; auto.
          apply dmut_assume_formula_dcl.
        + apply dmut_bind_right_dcl; auto.
          apply dmut_assume_formula_dcl.
    Qed.

    Definition dmut_wp_match_pair {AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£1} (x y : ùë∫) (œÉ œÑ : Ty) (s : Term Œ£1 (ty_prod œÉ œÑ))
      (d : DynamicMutator Œì1 Œì2 AT (Œ£1 ‚ñª (x :: œÉ) ‚ñª (y :: œÑ))) (d_dcl : dmut_dcl d)
      Œ£2 (Œ∂12 : Sub Œ£1 Œ£2) pc2 s2 Œπ2 (Hpc : instpc Œπ2 pc2) P :
      dmut_wp (dmut_match_pair s d) Œ∂12 pc2 s2 Œπ2 P <->
      (forall sl sr,
          inst (T := fun Œ£ => Term Œ£ _) (A := Lit (ty_prod œÉ œÑ)) (inst Œπ2 Œ∂12) s =
          (inst (T := fun Œ£ => Term Œ£ _) (A := Lit œÉ) Œπ2 sl,
           inst (T := fun Œ£ => Term Œ£ _) (A := Lit œÑ) Œπ2 sr) ->
          dmut_wp d (sub_snoc (sub_snoc Œ∂12 (x :: œÉ) sl) (y :: œÑ) sr) pc2 s2 Œπ2 P).
    Proof.
      unfold dmut_match_pair. cbn - [sub_wk1].
      destruct (term_get_pair_spec (subst (T := fun Œ£ => Term Œ£ _) Œ∂12 s)) as [[sl sr] Heqs|];
        fold_dmut_wp.
      - specialize (Heqs Œπ2). rewrite inst_subst in Heqs. split; auto.
        intros Hwp sl2 sr2 Heqs2. rewrite Heqs2 in Heqs.
        inversion Heqs. revert Hwp.
        eapply d_dcl; unfold sub_comp; rewrite ?inst_subst, ?inst_sub_snoc, ?inst_sub_id, ?inst_lift; auto.
        f_equal; auto. f_equal; auto.
      - split; intros Hwp.
        { intros sl sr Heqs.
          rewrite dmut_wp_fresh in Hwp; auto. specialize (Hwp (inst Œπ2 sl)).
          rewrite dmut_wp_fresh in Hwp; auto. specialize (Hwp (inst Œπ2 sr)).
          rewrite dmut_wp_bind_right in Hwp; auto.
          rewrite dmut_wp_assume_formula in Hwp; auto.
          rewrite ?inst_sub_snoc in Hwp. cbn - [sub_wk1] in Hwp.
          unfold sub_comp in Hwp. rewrite ?inst_subst, ?inst_sub_wk1 in Hwp.
          specialize (Hwp Heqs). revert Hwp.
          eapply d_dcl; unfold sub_comp; rewrite ?inst_subst, ?inst_sub_id, ?inst_lift; eauto.
          - apply dmut_bind_right_dcl; auto.
            apply dmut_assume_formula_dcl.
          - apply dmut_fresh_dcl.
            apply dmut_bind_right_dcl; auto.
            apply dmut_assume_formula_dcl.
        }
        { rewrite dmut_wp_fresh; auto. intros vl.
          rewrite dmut_wp_fresh; auto. intros vr.
          rewrite dmut_wp_bind_right; auto.
          rewrite dmut_wp_assume_formula; auto.
          unfold sub_comp. rewrite ?inst_sub_snoc. cbn - [sub_wk1].
          rewrite ?inst_subst, ?inst_sub_wk1. intros Heqs.
          specialize (Hwp (lift vl) (lift vr) Heqs). revert Hwp.
          eapply d_dcl; unfold sub_comp; rewrite ?inst_subst, ?inst_sub_id, ?inst_lift; eauto.
          - apply dmut_bind_right_dcl; auto.
            apply dmut_assume_formula_dcl.
          - apply dmut_fresh_dcl.
            apply dmut_bind_right_dcl; auto.
            apply dmut_assume_formula_dcl.
        }
    Qed.

    Lemma dmut_wp_freshen_recordpat' {Œì : PCtx} {œÉs : NCtx ùëπùë≠ Ty} {Œ£1 Œî : LCtx}
      (p : RecordPat œÉs Œî)
      (Œ£2 : LCtx) (Œ∂12 : Sub Œ£1 Œ£2) (pc2 : PathCondition Œ£2)
      (s2 : SymbolicState Œì Œ£2) (Œπ2 : SymInstance Œ£2) (Hpc : instpc Œπ2 pc2)
      (P : NamedEnv Lit œÉs * SymInstance Œî -> SCState Œì -> Prop) :
      dmut_wp (dmut_freshen_recordpat' id p) Œ∂12 pc2 s2 Œπ2 P <->
      forall (ts : NamedEnv Lit œÉs) (ŒπŒî : SymInstance Œî),
        record_pattern_match p ts = ŒπŒî -> P (ts,ŒπŒî) (inst Œπ2 s2).
    Proof.
      induction p; cbn - [dmut_wp].
      - split; cbn; auto.
        intros HP * Heq.
        subst.
        now destruct (nilView ts).
      - unfold dmut_fmap2. rewrite dmut_wp_bind; auto.
        rewrite IHp. split; intros Hwp ts ŒπŒî.
        + destruct (snocView ts) as [ts].
          destruct (snocView ŒπŒî) as [ŒπŒî]. cbn.
          specialize (Hwp ts ŒπŒî).
          remember (record_pattern_match p ts) as ŒπŒî'.
          intros Heq. dependent elimination Heq.
          specialize (Hwp eq_refl).
          rewrite dmut_wp_fmap, dmut_wp_sub in Hwp; auto.
          rewrite dmut_wp_freshtermvar in Hwp; auto.
          specialize (Hwp v). cbn in Hwp.
          rewrite ?inst_lift in Hwp.
          change (P (inst Œπ2 (subst Œ∂12 (lift ts)) ‚ñ∫ (rf :: œÑ ‚Ü¶ v) ,
                     inst Œπ2 (subst Œ∂12 (lift ŒπŒî')) ‚ñ∫ (x :: œÑ ‚Ü¶ v))
                    (inst Œπ2 s2)) in Hwp.
          now rewrite ?inst_subst, ?inst_lift in Hwp.
          clear. unfold sout_mapping_dcl. intros. cbn.
          change
            (inst Œπ1 (subst Œ∂01 (lift ts)) ‚ñ∫ (rf :: œÑ ‚Ü¶ inst Œπ1 a1) :: inst Œπ1 (subst Œ∂01 (lift ŒπŒî')) ‚ñ∫ (x :: œÑ ‚Ü¶ inst Œπ1 a1) =
             inst Œπ2 (subst Œ∂02 (lift ts)) ‚ñ∫ (rf :: œÑ ‚Ü¶ inst Œπ2 a2) :: inst Œπ2 (subst Œ∂02 (lift ŒπŒî')) ‚ñ∫ (x :: œÑ ‚Ü¶ inst Œπ2 a2)).
          rewrite ?inst_subst, ?inst_lift. cbn. now rewrite H1.
        + intros Heq.
          rewrite dmut_wp_fmap, dmut_wp_sub; auto.
          rewrite dmut_wp_freshtermvar; auto.
          intros v. cbn. rewrite ?inst_lift.
          change (P (inst Œπ2 (subst Œ∂12 (lift ts)) ‚ñ∫ (rf :: œÑ ‚Ü¶ v) ,
                     inst Œπ2 (subst Œ∂12 (lift ŒπŒî)) ‚ñ∫ (x :: œÑ ‚Ü¶ v))
                    (inst Œπ2 s2)).
          rewrite ?inst_subst, ?inst_lift.
          specialize (Hwp (env_snoc ts (_,_) v) (env_snoc ŒπŒî (_,_) v)).
          cbn in Hwp. now inster Hwp by now rewrite Heq.
          clear. unfold sout_mapping_dcl. intros. cbn.
          change
            (inst Œπ1 (subst Œ∂01 (lift ts)) ‚ñ∫ (rf :: œÑ ‚Ü¶ inst Œπ1 a1) :: inst Œπ1 (subst Œ∂01 (lift ŒπŒî)) ‚ñ∫ (x :: œÑ ‚Ü¶ inst Œπ1 a1) =
             inst Œπ2 (subst Œ∂02 (lift ts)) ‚ñ∫ (rf :: œÑ ‚Ü¶ inst Œπ2 a2) :: inst Œπ2 (subst Œ∂02 (lift ŒπŒî)) ‚ñ∫ (x :: œÑ ‚Ü¶ inst Œπ2 a2)).
          rewrite ?inst_subst, ?inst_lift. cbn. now rewrite H1.
        + clear. intros until Q; intros PQ.
          cbn - [sub_id sub_wk1]. intros HYP v. specialize (HYP v). revert HYP.
          rewrite ?inst_subst, ?inst_sub_wk1.
          rewrite <- ?sub_up1_id. cbn. rewrite ?sub_comp_id_left.
          destruct a1 as [ts0 ŒπŒî0], a2 as [ts2 ŒπŒî2]. cbn - [inst].
          admit.
    Admitted.

    Lemma dmut_wp_match_record {R AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£1 Œî} (t : Term Œ£1 (ty_record R))
      (p : @RecordPat ùë∫ (ùëπùë≠_Ty R) Œî) (d : DynamicMutator Œì1 Œì2 AT (Œ£1 ‚ñª‚ñª Œî)) (d_dcl : dmut_dcl d)
      Œ£2 (Œ∂12 : Sub Œ£1 Œ£2) pc2 (s2 : SymbolicState Œì1 Œ£2) (Œπ2 : SymInstance Œ£2) (Hpc : instpc Œπ2 pc2)
      (P : A -> SCState Œì2 -> Prop) :
      dmut_wp (dmut_match_record p t d) Œ∂12 pc2 s2 Œπ2 P <->
      forall ts : NamedEnv (Term _) (ùëπùë≠_Ty R),
        inst (T := fun Œ£ => Term Œ£ _) (A := Lit (ty_record R)) (inst Œπ2 Œ∂12) t = ùëπ_fold (inst Œπ2 ts) ->
        dmut_wp d (Œ∂12 ‚ñ∫‚ñ∫ record_pattern_match p ts) pc2 s2 Œπ2 P.
    Proof.
      unfold dmut_match_record. cbn.
      destruct (term_get_record_spec (subst (T := fun Œ£ => Term Œ£ _) Œ∂12 t)) as [ts Heqts|];
        fold_dmut_wp.
      - specialize (Heqts Œπ2). rewrite inst_subst in Heqts. split; auto.
        intros Hwp ts2 Heqts2. rewrite Heqts2 in Heqts.
        apply (f_equal (@ùëπ_unfold R)) in Heqts.
        rewrite ?ùëπ_unfold_fold in Heqts. revert Hwp.
        eapply d_dcl; rewrite ?inst_sub_id; eauto.
        unfold inst; cbn. rewrite ?env_map_cat.
        f_equal.
        change (inst Œπ2 (record_pattern_match p ts) = inst Œπ2 (record_pattern_match p ts2)).
        now rewrite ?inst_record_pattern_match, Heqts.
      - rewrite dmut_wp_bind; auto.
        split; intros Hwp.
        { intros ts Heqts.
          unfold dmut_freshen_recordpat in Hwp.
          rewrite dmut_wp_fmap in Hwp; auto.
          rewrite dmut_wp_freshen_recordpat' in Hwp; auto.
          specialize (Hwp (inst Œπ2 ts) _ eq_refl).
          rewrite <- inst_record_pattern_match in Hwp.
          remember (record_pattern_match p ts) as ts__R.
          cbn - [dmut_wp inst_term] in Hwp.
          rewrite subst_sub_id, inst_lift in Hwp.
          rewrite dmut_wp_bind_right, dmut_wp_assume_formula in Hwp; auto.
          cbn - [inst_term] in Hwp. fold_inst_term.
          rewrite inst_lift in Hwp. rewrite Heqts in Hwp.
          cbn in Hwp. inster Hwp by admit.
          rewrite inst_lift, dmut_wp_sub in Hwp.
          revert Hwp.
          eapply d_dcl; unfold sub_comp; rewrite ?inst_subst, ?inst_lift, ?inst_sub_id; eauto.
          unfold inst; cbn.
          rewrite ?env_map_cat.
          f_equal.
          change (inst (inst Œπ2 Œ∂12) (sub_id Œ£1) = inst Œπ2 Œ∂12).
          now rewrite inst_sub_id.
          change (inst (inst Œπ2 Œ∂12) (lift (inst Œπ2 ts__R)) = inst Œπ2 ts__R).
          now rewrite inst_lift.
          now apply dmut_sub_dcl.
          clear. unfold sout_mapping_dcl. destruct a1, a2; cbn - [inst_term].
          intros. fold_inst_term. subst. inversion H1. f_equal; auto.
          admit.
        }
    Admitted.

    Lemma dmut_match_enum_dcl {AT A E} `{InstLaws AT A} {Œì1 Œì2 Œ£1} (t : Term Œ£1 (ty_enum E))
      (d : ùë¨ùë≤ E -> DynamicMutator Œì1 Œì2 AT Œ£1) (d_dcl : forall K, dmut_dcl (d K)) :
      dmut_dcl (dmut_match_enum t d).
    Proof.
      intros until Q; intros PQ. rewrite ?dmut_wp_match_enum; auto.
      subst. rewrite H7. eapply d_dcl; eauto.
    Qed.

    Lemma dmut_match_sum_dcl {AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£ x y œÉ œÑ} (s : Term Œ£ (ty_sum œÉ œÑ))
      (dinl : DynamicMutator Œì1 Œì2 AT (Œ£ ‚ñª (x :: œÉ))) (dinl_dcl : dmut_dcl dinl)
      (dinr : DynamicMutator Œì1 Œì2 AT (Œ£ ‚ñª (y :: œÑ))) (dinr_dcl : dmut_dcl dinr) :
      dmut_dcl (dmut_match_sum s dinl dinr).
    Proof.
      intros until Q; intros PQ. rewrite ?dmut_wp_match_sum; auto. cbn.
      intros [Hl Hr].
      split.
      - intros sl Heq. specialize (Hl (lift (inst Œπ2 sl))).
        inster Hl by (rewrite inst_lift; intuition). revert Hl.
        eapply dinl_dcl; rewrite ?inst_sub_snoc, ?inst_lift; auto.
        f_equal. auto.
      - intros sr Heq. specialize (Hr (lift (inst Œπ2 sr))).
        inster Hr by (rewrite inst_lift; intuition). revert Hr.
        eapply dinr_dcl; rewrite ?inst_sub_snoc, ?inst_lift; auto.
        f_equal. auto.
    Qed.

    Lemma dmut_match_pair_dcl {AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£1 x y œÉ œÑ} (s : Term Œ£1 (ty_prod œÉ œÑ))
      (d : DynamicMutator Œì1 Œì2 AT (Œ£1 ‚ñª (x :: œÉ) ‚ñª (y :: œÑ))) (d_dcl : dmut_dcl d) :
      dmut_dcl (dmut_match_pair s d).
    Proof.
      intros until Q; intros PQ. rewrite ?dmut_wp_match_pair; auto.
      intros Hwp sl sr Heqs. specialize (Hwp (lift (inst Œπ2 sl)) (lift (inst Œπ2 sr))).
      rewrite ?inst_lift in Hwp. rewrite <- H7 in Heqs. specialize (Hwp Heqs). revert Hwp.
      eapply d_dcl; unfold sub_comp; rewrite ?inst_sub_snoc, ?inst_lift; auto.
      f_equal; auto. f_equal; auto.
    Qed.

    Lemma dmut_match_record_dcl {R AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£1 Œî} (t : Term Œ£1 (ty_record R))
      (p : @RecordPat ùë∫ (ùëπùë≠_Ty R) Œî) (d : DynamicMutator Œì1 Œì2 AT (Œ£1 ‚ñª‚ñª Œî)) (d_dcl : dmut_dcl d) :
      dmut_dcl (@dmut_match_record AT R Œì1 Œì2 Œ£1 Œî p t d).
    Proof.
      intros until Q; intros PQ. rewrite ?dmut_wp_match_record; auto.
      intros Hwp Œ∂__R Heqs. specialize (Hwp (lift (inst Œπ2 Œ∂__R))).
      rewrite ?inst_lift in Hwp. rewrite <- H7 in Heqs. specialize (Hwp Heqs). revert Hwp.
      eapply d_dcl; eauto. unfold inst at 1 3; cbn. rewrite ?env_map_cat.
      f_equal. exact H7. admit.
    Admitted.

    Lemma dmut_produce_chunk_dcl {Œì Œ£} (c : Chunk Œ£) :
      dmut_dcl (Œì1 := Œì) (dmut_produce_chunk c).
    Proof.
      unfold dmut_produce_chunk, dmut_modify_heap, dmut_modify.
      apply dmut_state_dcl. destruct s1 as [Œ¥1 h1], s2 as [Œ¥2 h2].
      cbn - [instantiate_list]. intros. inversion H0. cbn.
      change (List.map (inst ?Œπ) ?h) with (inst Œπ h).
      rewrite ?inst_subst. congruence.
    Qed.

    Lemma dmut_produce_dcl {Œì Œ£} (asn : Assertion Œ£) :
      dmut_dcl (Œì1 := Œì) (dmut_produce asn).
    Proof.
      induction asn; cbn.
      - apply dmut_assume_formula_dcl.
      - apply dmut_produce_chunk_dcl.
      - apply dmut_demonic_binary_dcl; apply dmut_bind_right_dcl;
          unfold dmut_assume_term; auto using dmut_assume_formula_dcl.
      - now apply dmut_match_enum_dcl.
      - now apply dmut_match_sum_dcl.
      - admit.
      - now apply dmut_match_pair_dcl.
      - admit.
      - now apply dmut_match_record_dcl.
      - admit.
      - now apply dmut_bind_right_dcl.
      - now apply dmut_fresh_dcl.
      - admit.
    Admitted.

    Lemma dmut_consume_chunk_dcl {Œì Œ£} (c : Chunk Œ£) :
      dmut_dcl (Œì1 := Œì) (dmut_consume_chunk c).
    Proof.
      unfold dmut_consume_chunk.
      apply dmut_bind_dcl.
      apply dmut_state_dcl. destruct s1, s2; cbn.
      intros. congruence.
      intros until Q. intros PQ.
    Admitted.

    Lemma dmut_consume_dcl {Œì Œ£} (asn : Assertion Œ£) :
      dmut_dcl (Œì1 := Œì) (dmut_consume asn).
    Proof.
      induction asn; cbn.
      - apply dmut_assert_formula_dcl.
      - apply dmut_consume_chunk_dcl.
      - apply dmut_demonic_binary_dcl; apply dmut_bind_right_dcl;
          unfold dmut_assume_term; auto using dmut_assume_formula_dcl.
      - now apply dmut_match_enum_dcl.
      - now apply dmut_match_sum_dcl.
      - admit.
      - now apply dmut_match_pair_dcl.
      - admit.
      - now apply dmut_match_record_dcl.
      - admit.
      - now apply dmut_bind_right_dcl.
      - admit.
      - admit.
    Admitted.

    Lemma dmut_exec_dcl {Œì œÑ Œ£} (s : Stm Œì œÑ) :
      dmut_dcl (Œ£0 := Œ£) (dmut_exec s).
    Proof. Admitted.

    Definition APPROX Œì1 Œì2 AT A {instA : Inst AT A} : Type :=
      forall Œ£ (Œπ : SymInstance Œ£),
        DynamicMutator Œì1 Œì2 AT Œ£ -> SCMut Œì1 Œì2 A -> Prop.
    Arguments APPROX _ _ _ _ {_}.

    Definition bapprox {Œì1 Œì2 AT A} {instA : Inst AT A} : APPROX Œì1 Œì2 AT A :=
      fun Œ£0 Œπ0 dm sm =>
        forall Œ£1 (Œ∂01 : Sub Œ£0 Œ£1) (pc1 : PathCondition Œ£1) (Œπ1 : SymInstance Œ£1) POST s1,
          Œπ0 = inst Œπ1 Œ∂01 ->
          instpc Œπ1 pc1 ->
          dmut_wp dm Œ∂01 pc1 s1 Œπ1 POST ->
          scmut_wp sm POST (inst Œπ1 s1).

    Definition bapprox2 {Œì1 Œì2 AT A} {instA : Inst AT A} : APPROX Œì1 Œì2 AT A :=
      fun Œ£0 Œπ0 dm sm =>
        forall POST sc,
          dmut_wp dm (lift Œπ0) nil (lift sc) env_nil POST ->
          scmut_wp sm POST sc.

    Lemma bapprox_bapprox2 {AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£} (Œπ : SymInstance Œ£)
      (dm : DynamicMutator Œì1 Œì2 AT Œ£) (dm_dcl : dmut_dcl dm) (sm : SCMut Œì1 Œì2 A) :
      bapprox Œπ dm sm <-> bapprox2 Œπ dm sm.
    Proof.
      unfold bapprox, bapprox2. split; intros HYP.
      - intros POST sc Hwp.
        specialize (HYP ctx_nil (lift Œπ) nil env_nil POST (lift sc)).
        rewrite ?inst_lift in HYP. apply HYP; auto. constructor.
      - intros ? ? ? ? ? ? HŒπ Hpc Hwp. specialize (HYP POST (inst Œπ1 s1)).
        apply HYP. revert Hwp.
        apply (dm_dcl Œ£1 Œµ Œ∂01 _ _ (lift Œπ1)); rewrite ?inst_lift; auto.
        constructor.
    Qed.

    Definition inst_dmut {AT A} `{Inst AT A} {Œì1 Œì2 Œ£} (Œπ : SymInstance Œ£) (d : DynamicMutator Œì1 Œì2 AT Œ£) : SCMut Œì1 Œì2 A :=
      fun sc => inst_symoutcome Œπ (d Œ£ (sub_id Œ£) nil (lift sc)).
    Definition inst_dmut' {AT A} `{Inst AT A} {Œì1 Œì2 Œ£} (Œπ : SymInstance Œ£) (d : DynamicMutator Œì1 Œì2 AT Œ£) : SCMut Œì1 Œì2 A :=
      fun sc => inst_symoutcome env_nil (d ctx_nil (lift Œπ) nil (lift sc)).

    Definition bapprox3 {Œì1 Œì2 AT A} {instA : Inst AT A} : APPROX Œì1 Œì2 AT A :=
      fun Œ£0 Œπ0 dm sm =>
        forall POST sc,
          scmut_wp (inst_dmut Œπ0 dm) POST sc ->
          scmut_wp sm POST sc.

    Definition bapprox4 {Œì1 Œì2 AT A} {instA : Inst AT A} : APPROX Œì1 Œì2 AT A :=
      fun Œ£0 Œπ0 dm sm =>
        forall POST sc,
          scmut_wp (inst_dmut' Œπ0 dm) POST sc ->
          scmut_wp sm POST sc.

    Lemma bapprox_bapprox3 {AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£} (Œπ : SymInstance Œ£)
      (dm : DynamicMutator Œì1 Œì2 AT Œ£) (dm_dcl : dmut_dcl dm) (sm : SCMut Œì1 Œì2 A) :
      bapprox Œπ dm sm <-> bapprox3 Œπ dm sm.
    Proof.
      split; unfold bapprox, bapprox3; intros HYP.
      - intros POST sc Hwp.
        specialize (HYP Œ£ (sub_id _) nil Œπ POST (lift sc)).
        inster HYP by rewrite ?inst_sub_id; constructor.
        rewrite inst_lift in HYP. apply HYP.
        unfold dmut_wp. rewrite sout_wp_wp'. exact Hwp.
      - intros ? ? ? ? ? ? HŒπ Hpc Hwp. apply HYP.
        unfold scmut_wp, inst_dmut.
        change (sout_wp' (dm Œ£ (sub_id Œ£) nil (lift (inst Œπ1 s1))) Œπ
                         (fun X : SCMutResult Œì2 A => POST (scmutres_value X) (scmutres_state X))).
        rewrite <- sout_wp_wp'. fold_dmut_wp. revert Hwp.
        eapply dm_dcl; rewrite ?inst_sub_id, ?inst_lift; eauto.
        constructor.
    Qed.

    Lemma bapprox_bapprox4 {AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£} (Œπ : SymInstance Œ£)
      (dm : DynamicMutator Œì1 Œì2 AT Œ£) (dm_dcl : dmut_dcl dm) (sm : SCMut Œì1 Œì2 A) :
      bapprox Œπ dm sm <-> bapprox4 Œπ dm sm.
    Proof.
      split; unfold bapprox, bapprox4; intros HYP.
      - intros POST sc Hwp.
        specialize (HYP ctx_nil (lift Œπ) nil env_nil POST (lift sc)).
        inster HYP by rewrite ?inst_lift; constructor.
        rewrite inst_lift in HYP. apply HYP.
        unfold dmut_wp. rewrite sout_wp_wp'. exact Hwp.
      - intros ? ? ? ? ? ? HŒπ Hpc Hwp. apply HYP.
        unfold scmut_wp, inst_dmut'.
        change (sout_wp' (dm ctx_nil (lift Œπ) nil (lift (inst Œπ1 s1))) env_nil
                         (fun X : SCMutResult Œì2 A => POST (scmutres_value X) (scmutres_state X))).
        rewrite <- sout_wp_wp'. fold_dmut_wp. revert Hwp.
        eapply dm_dcl; rewrite ?inst_sub_id, ?inst_lift; eauto.
        constructor.
    Qed.

    Lemma bapprox_demonic_binary {AT A} `{Inst AT A} {Œì1 Œì2 Œ£} (Œπ : SymInstance Œ£)
          (dm1 dm2 : DynamicMutator Œì1 Œì2 AT Œ£) (sm1 sm2 : SCMut Œì1 Œì2 A) :
      bapprox Œπ dm1 sm1 ->
      bapprox Œπ dm2 sm2 ->
      bapprox Œπ (dmut_demonic_binary dm1 dm2) (scmut_demonic_binary sm1 sm2).
    Proof. unfold bapprox. cbn. intuition. Qed.

    Lemma bapprox_angelic_binary {AT A} `{Inst AT A} {Œì1 Œì2 Œ£} (Œπ : SymInstance Œ£)
          (dm1 dm2 : DynamicMutator Œì1 Œì2 AT Œ£) (sm1 sm2 : SCMut Œì1 Œì2 A) :
      bapprox Œπ dm1 sm1 ->
      bapprox Œπ dm2 sm2 ->
      bapprox Œπ (dmut_angelic_binary dm1 dm2) (scmut_angelic_binary sm1 sm2).
    Proof. unfold bapprox. cbn. intuition. Qed.

    Lemma bapprox_fresh {Œì Œ£ œÇ œÑ} (Œπ : SymInstance Œ£)
          (dm : DynamicMutator Œì Œì Unit (Œ£ ‚ñª (œÇ,œÑ))) (d_dcl : dmut_dcl dm)
          (sm : Lit œÑ -> SCMut Œì Œì unit) :
      (forall v, bapprox (env_snoc Œπ _ v) dm (sm v)) ->
      bapprox Œπ
        (dmut_fresh œÇ œÑ dm)
        (scmut_demonic sm).
    Proof.
      unfold bapprox, scmut_demonic. intros HYP * HŒπ Hpc Hwp vœÑ.
      apply (HYP vœÑ _ (sub_snoc Œ∂01 (œÇ :: œÑ) (term_lit œÑ vœÑ)) pc1); auto.
      subst Œπ; reflexivity.
      unfold dmut_fresh in Hwp. cbn in Hwp. specialize (Hwp vœÑ). revert Hwp.
      eapply (d_dcl _ _ _ _ _ (sub_snoc (sub_id Œ£1) (fresh Œ£1 (Some œÇ) :: œÑ) (term_lit œÑ vœÑ))); auto.
      - now rewrite inst_sub_snoc, inst_sub_id.
      - now rewrite inst_subst, inst_sub_wk1.
      - now rewrite inst_subst, inst_sub_wk1.
      - unfold sub_comp. now rewrite ?inst_sub_snoc, ?inst_subst, ?inst_sub_wk1.
    Qed.

    Lemma bapprox2_fresh {Œì Œ£ œÇ œÑ} (Œπ : SymInstance Œ£)
          (dm : DynamicMutator Œì Œì Unit (Œ£ ‚ñª (œÇ,œÑ))) (d_dcl : dmut_dcl dm)
          (sm : Lit œÑ -> SCMut Œì Œì unit) :
      (forall v, bapprox2 (env_snoc Œπ _ v) dm (sm v)) ->
      bapprox2 Œπ
        (dmut_fresh œÇ œÑ dm)
        (scmut_demonic sm).
    Proof.
      unfold bapprox2, scmut_demonic. intros HYP POST sc Hwp vœÑ. apply HYP.
      rewrite dmut_wp_fresh in Hwp; eauto. apply (Hwp vœÑ). constructor.
    Qed.

    Lemma bapprox_pure {AT A} `{InstLaws AT A} {Œì Œ£} (Œπ : SymInstance Œ£) (t : AT Œ£) (a : A) :
      a = inst Œπ t ->
      bapprox Œπ (dmut_pure (Œì := Œì) t) (scmut_pure a).
    Proof.
      unfold bapprox. intros -> * -> Hpc. cbn.
      now rewrite inst_subst.
    Qed.

    Lemma bapprox_block {AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£} (Œπ : SymInstance Œ£) :
      bapprox Œπ (@dmut_block Œì1 Œì2 AT Œ£) scmut_block.
    Proof. unfold bapprox; auto. Qed.

    Lemma bapprox_bind {AT A BT B} `{InstLaws AT A, InstLaws BT B}
      {Œì1 Œì2 Œì3 Œ£0} (Œπ0 : SymInstance Œ£0)
      (dma : DynamicMutator Œì1 Œì2 AT Œ£0) (sma : SCMut Œì1 Œì2 A)
      (dmf : dmut_arrow Œì2 Œì3 AT BT Œ£0)
      (dmf_dcl : dmut_arrow_dcl dmf)
      (smf : A -> SCMut Œì2 Œì3 B) :
      bapprox Œπ0 dma sma ->
      (forall (a0 : AT Œ£0),
          bapprox Œπ0 (dmf Œ£0 (sub_id _) a0) (smf (inst Œπ0 a0))) ->
      bapprox Œπ0 (dmut_bind dma dmf) (scmut_bind sma smf).
    Proof.
      unfold bapprox. intros Hapa Hapf * HŒπ Hpc.
      rewrite dmut_wp_bind; eauto. rewrite scmut_wp_bind.
      intros Hwp. eapply Hapa; eauto. revert Hwp.
      apply dmut_wp_monotonic. intros a sc2 Hwp.
      apply Hapf in Hwp; auto. revert Hwp. now rewrite ?inst_lift.
    Qed.

    Lemma bapprox_bind_right {AT A BT B} `{InstLaws AT A, InstLaws BT B}
      {Œì1 Œì2 Œì3 Œ£0} (Œπ0 : SymInstance Œ£0)
      (dma : DynamicMutator Œì1 Œì2 AT Œ£0) (sma : SCMut Œì1 Œì2 A)
      (dmb : DynamicMutator Œì2 Œì3 BT Œ£0) (dmb_dcl : dmut_dcl dmb) (smb : SCMut Œì2 Œì3 B) :
      bapprox Œπ0 dma sma ->
      bapprox Œπ0 dmb smb ->
      bapprox Œπ0 (dmut_bind_right dma dmb) (scmut_bind_right sma smb).
    Proof.
      unfold bapprox. intros A1 A2 * -> Hpc1.
      rewrite dmut_wp_bind_right; auto.
      unfold scmut_bind_right. rewrite scmut_wp_bind.
      intros Hwp; eapply A1 in Hwp; eauto. revert Hwp.
      apply scmut_wp_monotonic; intros a s2.
      intros Hwp; eapply A2 in Hwp; eauto. revert Hwp. 
      now rewrite inst_lift.
    Qed.

    Lemma bapprox_bind_left {AT A BT B} `{InstLaws AT A, InstLaws BT B}
      {Œì1 Œì2 Œì3 Œ£0} (Œπ0 : SymInstance Œ£0)
      (dma : DynamicMutator Œì1 Œì2 AT Œ£0) (sma : SCMut Œì1 Œì2 A)
      (dmb : DynamicMutator Œì2 Œì3 BT Œ£0) (dmb_dcl : dmut_dcl dmb) (smb : SCMut Œì2 Œì3 B) :
      bapprox Œπ0 dma sma ->
      bapprox Œπ0 dmb smb ->
      bapprox Œπ0 (dmut_bind_left dma dmb) (scmut_bind_left sma smb).
    Proof.
      intros A1 A2. unfold bapprox. intros * -> Hpc1.
      rewrite dmut_wp_bind_left; auto.
      unfold scmut_bind_left. rewrite scmut_wp_bind.
      intros Hwp; eapply A1 in Hwp; eauto. revert Hwp.
      apply scmut_wp_monotonic; intros a s2. rewrite scmut_wp_bind.
      intros Hwp; eapply A2 in Hwp; eauto. revert Hwp.
      now rewrite inst_lift.
    Qed.

    Lemma bapprox2_assume_formula {Œì Œ£} (Œπ : SymInstance Œ£) (fml : Formula Œ£) :
      bapprox2
        (Œì1 := Œì) (Œì2 := Œì) Œπ
        (dmut_assume_formula fml)
        (scmut_assume_formula Œπ fml).
    Proof.
      unfold bapprox2. intros POST sc.
      rewrite dmut_wp_assume_formula; auto. rewrite ?inst_lift.
      intuition.
      constructor.
    Qed.

    Lemma bapprox_angelic {AT A BT B} `{InstLaws AT A, InstLaws BT B} {Œì Œ£} (Œπ : SymInstance Œ£)
      (dm : AT Œ£ -> DynamicMutator Œì Œì BT Œ£)
      (sm : A -> SCMut Œì Œì B) :
      (forall a, bapprox Œπ (dm a) (sm (inst Œπ a))) ->
      bapprox Œπ
        (dmut_angelic dm)
        (scmut_angelic sm).
    Proof.
      unfold bapprox, dmut_angelic.
      intros HYP * HŒπ Hpc [a Hwp]. rewrite scmut_wp_angelic. exists (inst Œπ a).
      change (dmut_wp (dm a) Œ∂01 pc1 s1 Œπ1 POST) in Hwp.
      revert Hwp. apply HYP; auto.
    Qed.

    Lemma bapprox_sub {AT A} `{Inst AT A, Subst AT} {Œì Œ£0 Œ£1} (Œ∂01 : Sub Œ£0 Œ£1)
      (d : DynamicMutator Œì Œì AT Œ£0) (s : SCMut Œì Œì A) (Œπ0 : SymInstance Œ£0) (Œπ1 : SymInstance Œ£1) :
      Œπ0 = inst Œπ1 Œ∂01 ->
      bapprox Œπ0 d s -> bapprox Œπ1 (dmut_sub Œ∂01 d) s.
    Proof.
      intros HŒπ0 Hap. unfold bapprox. intros * HŒπ1 Hpc2.
      rewrite dmut_wp_sub. apply Hap; auto.
      unfold sub_comp; rewrite inst_subst; now subst.
    Qed.

    Lemma bapprox_assume_formula {Œì Œ£} (Œπ : SymInstance Œ£) (fml : Formula Œ£) :
      bapprox
        (Œì1 := Œì) (Œì2 := Œì) Œπ
        (dmut_assume_formula fml)
        (scmut_assume_formula Œπ fml).
    Proof.
      unfold bapprox. intros * -> Hpc Hwp Hfml. revert Hwp.
      rewrite dmut_wp_assume_formula; eauto. cbn. intuition.
    Qed.

    Lemma bapprox_assert_formula {Œì Œ£} (Œπ : SymInstance Œ£) (fml : Formula Œ£) :
      bapprox
        (Œì1 := Œì) (Œì2 := Œì) Œπ
        (dmut_assert_formula fml)
        (scmut_assert_formula Œπ fml).
    Proof.
      unfold bapprox. intros * HŒπ Hpc1.
      rewrite dmut_wp_assert_formula; eauto.
      cbn. intuition.
    Qed.

    Lemma bapprox_state {AT A} `{Subst AT, Inst AT A} {Œì1 Œì2 Œ£0} (Œπ0 : SymInstance Œ£0)
          (f : forall Œ£1 (Œ∂01 : Sub Œ£0 Œ£1), SymbolicState Œì1 Œ£1 -> Pair AT (SymbolicState Œì2) Œ£1)
          (g : SCState Œì1 -> A * SCState Œì2)
          (fg : forall Œ£1 Œ∂01 s1 Œπ1,
                 Œπ0 = inst Œπ1 Œ∂01 -> inst Œπ1 (f Œ£1 Œ∂01 s1) = g (inst Œπ1 s1)) :
      bapprox Œπ0 (dmut_state f) (scmut_state g).
    Proof.
      unfold bapprox. intros * HŒπ Hpc.
      specialize (fg Œ£1 Œ∂01 s1 Œπ1 HŒπ).
      cbn. rewrite dmut_wp_state.
      destruct (f Œ£1 Œ∂01 s1) as [a1 s21], (g (inst Œπ1 s1)) as [a sc2]; cbn.
      inversion fg. now subst.
    Qed.

    Lemma bapprox_produce_chunk {Œì Œ£} (Œπ : SymInstance Œ£) (c : Chunk Œ£) :
      bapprox
        (Œì1 := Œì) (Œì2 := Œì) Œπ
        (dmut_produce_chunk c)
        (scmut_produce_chunk (inst Œπ c)).
    Proof.
      unfold bapprox, dmut_produce_chunk, scmut_produce_chunk.
      unfold scmut_wp.
      intros * -> Hpc1. destruct s1. cbn. now rewrite inst_subst.
    Qed.

    Lemma bapprox_match_enum {AT A E} `{InstLaws AT A} {Œì1 Œì2 Œ£1} (t : Term Œ£1 (ty_enum E))
      (dm : Lit (ty_enum E) -> DynamicMutator Œì1 Œì2 AT Œ£1) (dm_dcl : forall x, dmut_dcl (dm x))
      (sm : Lit (ty_enum E) -> SCMut Œì1 Œì2 A)
      (Œπ : SymInstance Œ£1) :
      (forall k, bapprox Œπ (dm k) (sm k)) ->
      bapprox
        Œπ
        (dmut_match_enum t dm)
        (scmut_match_enum (inst (T := fun Œ£ => Term Œ£ (ty_enum E)) Œπ t) sm).
    Proof.
      unfold bapprox. intros Hap * ? Hpc. subst.
      rewrite dmut_wp_match_enum; auto. now apply Hap.
    Qed.

    Lemma bapprox_match_sum {AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£1} {x y : ùë∫} {œÉ œÑ} (s : Term Œ£1 (ty_sum œÉ œÑ))
      (dinl : DynamicMutator Œì1 Œì2 AT (Œ£1 ‚ñª (x :: œÉ))) (dinl_dcl : dmut_dcl dinl)
      (dinr : DynamicMutator Œì1 Œì2 AT (Œ£1 ‚ñª (y :: œÑ))) (dinr_dcl : dmut_dcl dinr)
      (sinl : Lit œÉ -> SCMut Œì1 Œì2 A) (sinr : Lit œÑ -> SCMut Œì1 Œì2 A) (Œπ : SymInstance Œ£1) :
      (forall v, bapprox (env_snoc Œπ _ v) dinl (sinl v)) ->
      (forall v, bapprox (env_snoc Œπ _ v) dinr (sinr v)) ->
      bapprox
        Œπ
        (dmut_match_sum s dinl dinr)
        (scmut_match_sum (inst (T := fun Œ£ => Term Œ£ (ty_sum œÉ œÑ)) (A := Lit œÉ + Lit œÑ) Œπ s) sinl sinr).
    Proof.
      unfold bapprox. intros Hapl Hapr * ? Hpc.
      rewrite dmut_wp_match_sum; auto. intros [Hl Hr].
      destruct (inst Œπ s) eqn:Heqs; [ clear Hr | clear Hl ]; subst Œπ.
      + specialize (Hl (term_lit œÉ l) Heqs). revert Hl. now apply Hapl.
      + specialize (Hr (term_lit œÑ l) Heqs). revert Hr. now apply Hapr.
    Qed.

    Lemma bapprox_match_pair {AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£1} {x y : ùë∫} {œÉ œÑ} (s : Term Œ£1 (ty_prod œÉ œÑ))
      (dm : DynamicMutator Œì1 Œì2 AT (Œ£1 ‚ñª (x :: œÉ) ‚ñª (y :: œÑ))) (dm_dcl : dmut_dcl dm)
      (sm : Lit œÉ -> Lit œÑ -> SCMut Œì1 Œì2 A) (Œπ : SymInstance Œ£1) :
      (forall vl vr, bapprox (env_snoc (env_snoc Œπ _ vl) _ vr) dm (sm vl vr)) ->
      bapprox
        Œπ
        (dmut_match_pair s dm)
        (scmut_match_pair (inst (T := fun Œ£ => Term Œ£ (ty_prod œÉ œÑ)) (A := Lit œÉ * Lit œÑ) Œπ s) sm).
    Proof.
      unfold bapprox. intros Hap * ? Hpc.
      rewrite dmut_wp_match_pair; auto. intros Hwp.
      destruct (inst Œπ s) as [vl vr] eqn:Heqs. subst Œπ.
      specialize (Hwp (lift vl) (lift vr) Heqs). revert Hwp.
      now apply Hap.
    Qed.

    Lemma bapprox_match_record {R AT A} `{InstLaws AT A} {Œì1 Œì2 Œ£0 Œî} (t : Term Œ£0 (ty_record R))
      (p : @RecordPat ùë∫ (ùëπùë≠_Ty R) Œî) (dm : DynamicMutator Œì1 Œì2 AT (Œ£0 ‚ñª‚ñª Œî)) (dm_dcl : dmut_dcl dm)
      (sm : SymInstance Œî -> SCMut Œì1 Œì2 A) (Œπ : SymInstance Œ£0) :
      (forall Œπ__Œî : SymInstance Œî, bapprox (env_cat Œπ Œπ__Œî) dm (sm Œπ__Œî)) ->
      bapprox
        Œπ
        (dmut_match_record p t dm)
        (scmut_match_record p (inst (T := fun Œ£ => Term Œ£ (ty_record R)) Œπ t) sm).
    Proof.
      unfold bapprox. intros Hap * HŒπ Hpc.
      rewrite dmut_wp_match_record; auto. intros Hwp.
      unfold scmut_match_record.
      specialize (Hwp (lift (ùëπ_unfold (inst (T := fun Œ£ => Term Œ£ _) Œπ t)))).
      inster Hwp by now rewrite inst_lift, ùëπ_fold_unfold, HŒπ.
      eapply Hap; eauto. cbn [Lit].
      generalize (ùëπ_unfold (inst (T := fun Œ£ => Term Œ£ (ty_record R)) (A := ùëπùëª R) Œπ t)).
      subst. clear. intros ts. unfold inst at 2; cbn.
      rewrite env_map_cat. f_equal.
      change (record_pattern_match p ts = inst Œπ1 (record_pattern_match p (lift ts))).
      now rewrite inst_record_pattern_match, inst_lift.
    Qed.

    Lemma bapprox_produce {Œì Œ£} (Œπ : SymInstance Œ£) (asn : Assertion Œ£) :
      bapprox
        (Œì1 := Œì) (Œì2 := Œì) Œπ
        (dmut_produce asn)
        (scmut_produce Œπ asn).
    Proof.
      induction asn; cbn - [subst].
      - apply bapprox_assume_formula.
      - apply bapprox_produce_chunk.
      - apply bapprox_demonic_binary; apply bapprox_bind_right;
          try apply bapprox_assume_formula; auto using dmut_produce_dcl.
      - apply bapprox_match_enum; auto using dmut_produce_dcl.
      - apply bapprox_match_sum; auto using dmut_produce_dcl.
      - admit.
      - apply bapprox_match_pair; auto using dmut_produce_dcl.
      - admit.
      - apply bapprox_match_record; auto using dmut_produce_dcl.
      - admit.
      - apply bapprox_bind_right; auto using dmut_produce_dcl.
      - apply bapprox_fresh; auto using dmut_produce_dcl.
      - unfold bapprox. intuition.
    Admitted.

    Lemma match_chunk_eqb_spec {Œ£} (ce cr : Chunk Œ£) (fmls : List Formula Œ£) :
      OptionSpec
        (fun fmls2 =>
           forall Œπ : SymInstance Œ£,
             instpc Œπ fmls2 ->
             inst Œπ ce = inst Œπ cr /\ instpc Œπ fmls)
        True
        (Soundness.MUT.match_chunk_eqb ce cr fmls).
    Proof.
      destruct ce, cr; cbn; try constructor; auto.
      - destruct (eq_dec p p0); cbn.
        + destruct e; cbn. admit.
        + now constructor.
      - destruct (eq_dec_het r r0); cbn.
        + dependent elimination e; cbn. admit.
        + now constructor.
    Admitted.

    Lemma heap_extractions_map {A B} (f : A -> B) (h : list A) :
      heap_extractions (List.map f h) = List.map (base.prod_map f (List.map f)) (heap_extractions h).
    Proof.
      induction h; cbn.
      - reflexivity.
      - f_equal.
        rewrite IHh.
        rewrite ?List.map_map.
        apply List.map_ext.
        intros [x xs]. reflexivity.
    Qed.

    Lemma bapprox_consume_chunk {Œì Œ£} (Œπ : SymInstance Œ£) (c : Chunk Œ£) :
      bapprox
        (Œì1 := Œì) (Œì2 := Œì) Œπ
        (dmut_consume_chunk c)
        (scmut_consume_chunk (inst Œπ c)).
    Proof.
      unfold bapprox, dmut_consume_chunk, scmut_consume_chunk.
      intros * HŒπ Hpc.
      unfold dmut_get_heap, scmut_get_heap, scmut_state_heap.
      rewrite dmut_wp_bind, scmut_wp_bind; auto.
      rewrite dmut_wp_state.
      rewrite dmut_wp_bind; auto.
      rewrite dmut_wp_angelic_list. intros [[Œîpc h'] [HIn Hwp]].
      rewrite subst_sub_id in HIn.
      cbn - [dmut_wp] in Hwp. rewrite dmut_wp_bind_right in Hwp; auto.
      rewrite dmut_wp_assert_formulas in Hwp; auto.
      rewrite ?inst_lift in Hwp. destruct Hwp as [HŒîpc Hwp].
      destruct s1 as [Œ¥1 h1]. cbn [symbolicstate_heap] in HIn. cbn in Hwp.
      rewrite ?inst_subst, ?inst_lift in Hwp.
      rewrite scmut_wp_state; cbn - [scmut_wp extract_chunk_eqb].
      unfold scmut_wp, scmut_angelick_list.
      rewrite outcome_satisfy_angelick_list.
      left. exists (inst Œπ h').
      split.
      - apply base.elem_of_list_In in HIn.
        unfold Soundness.MUT.extract_chunk_eqb, extract_chunk_eqb in *.
        unfold base.omap in HIn.
        apply list.elem_of_list_omap in HIn.
        destruct HIn as [[c' h''] [HIn Heq]].
        apply List.in_map_iff.
        destruct (match_chunk_eqb_spec c c' nil); cbn in Heq; try discriminate.
        inversion Heq. subst h'' a. clear Heq.
        specialize (H Œπ). inster H by (subst; auto). destruct H as [H _].
        exists (inst Œπ c', inst (T := List Chunk) Œπ h'). cbn.
        apply base.elem_of_list_In in HIn.
        split; auto. apply List.filter_In.
        split.
        + unfold lift, inst in HIn. cbn in HIn.
          rewrite List.map_map in HIn.
          rewrite heap_extractions_map in HIn.
          rewrite List.in_map_iff in HIn.
          destruct HIn as [[c1 h1'] [Heq HIn]].
          unfold base.prod_map in Heq; cbn in Heq.
          rewrite <- List.map_map in Heq.
          change (lift (inst Œπ1 c1) :: lift (inst Œπ1 h1') = c' :: h') in Heq.
          inversion Heq. subst. clear Heq.
          rewrite ?inst_lift in *.
          unfold inst at 3. cbn.
          rewrite heap_extractions_map.
          rewrite List.in_map_iff.
          exists (c1, h1'). split; auto.
        + destruct (MUT.match_chunk_eqb_spec (inst Œπ c) (inst Œπ c')); auto.
      - cbn; now subst.
      - admit.
      - admit.
    Admitted.

    Lemma bapprox_consume {Œì Œ£} (Œπ : SymInstance Œ£) (asn : Assertion Œ£) :
      bapprox
        (Œì1 := Œì) (Œì2 := Œì) Œπ
        (dmut_consume asn)
        (scmut_consume Œπ asn).
    Proof.
      induction asn; cbn - [subst].
      - apply bapprox_assert_formula.
      - apply bapprox_consume_chunk.
      - apply bapprox_demonic_binary; apply bapprox_bind_right;
          auto using dmut_consume_dcl.
        apply bapprox_assume_formula.
        apply bapprox_assume_formula.
      - apply bapprox_match_enum; auto using dmut_consume_dcl.
      - apply bapprox_match_sum; auto using dmut_consume_dcl.
      - admit.
      - apply bapprox_match_pair; auto using dmut_consume_dcl.
      - admit.
      - apply bapprox_match_record; auto using dmut_consume_dcl.
      - admit.
      - apply bapprox_bind_right; auto using dmut_consume_dcl.
      - apply (bapprox_angelic (AT := fun Œ£ => Term Œ£ œÑ)). intros t.
        eapply bapprox_sub; eauto. now rewrite inst_sub_snoc, inst_sub_id.
      - admit.
    Admitted.

    Lemma bapprox_call {Œì Œî œÑ Œ£} (c : SepContract Œî œÑ) (ts : NamedEnv (Term Œ£) Œî) (Œπ : SymInstance Œ£) :
      bapprox Œπ (@dmut_call Œì Œî œÑ Œ£ c ts) (scmut_call c (inst Œπ ts)).
    Proof.
      destruct c as [Œ£__c Œ¥ pre result post]; cbn [dmut_call scmut_call].
      apply bapprox_angelic. intros Œ∂. unfold bapprox. intros * HŒπ Hpc.
      rewrite dmut_wp_bind_right; auto.
      rewrite dmut_wp_assert_formulas; auto.
      intros [Hfmls Hwp]. rewrite dmut_wp_sub in Hwp.
      rewrite scmut_wp_angelic.
      assert (inst Œπ ts = inst (inst Œπ Œ∂) Œ¥) as Heq.
      { rewrite <- HŒπ in Hfmls. clear - Hfmls.
        induction ts; [destruct (nilView Œ¥) | destruct (snocView Œ¥)].
        - reflexivity.
        - cbn - [inst] in Hfmls.
          rewrite inst_pathcondition_cons in Hfmls.
          destruct Hfmls as [Hfml Hfmls].
          cbn. f_equal.
          + now apply IHts.
          + now rewrite <- inst_subst.
      }
      exists Heq.
      rewrite dmut_wp_bind_right in Hwp; auto.
      eapply bapprox_consume in Hwp; eauto. revert Hwp.
      unfold sub_comp, scmut_bind_right.
      rewrite inst_subst, inst_lift, scmut_wp_bind.
      subst Œπ. apply scmut_wp_monotonic.
      intros _ sc__consume Hwp.
      rewrite dmut_wp_fresh in Hwp; auto.
      rewrite scmut_wp_demonic. intros v.
      specialize (Hwp v).
      rewrite scmut_wp_bind.
      rewrite dmut_wp_bind_right in Hwp; auto.
      eapply bapprox_produce in Hwp; eauto. revert Hwp.
      rewrite inst_sub_snoc, inst_subst, inst_lift. cbn.
      apply scmut_wp_monotonic.
      intros _ sc__produce.
      now rewrite inst_lift.
      apply dmut_pure_dcl.
      apply dmut_bind_right_dcl.
      apply dmut_produce_dcl.
      apply dmut_pure_dcl.
      apply dmut_fresh_dcl.
      apply dmut_bind_right_dcl.
      apply dmut_produce_dcl.
      apply dmut_pure_dcl.
      apply dmut_sub_dcl.
      apply dmut_bind_right_dcl.
      apply dmut_consume_dcl.
      apply dmut_fresh_dcl.
      apply dmut_bind_right_dcl.
      apply dmut_produce_dcl.
      apply dmut_pure_dcl.
    Qed.

    Lemma eval_exp_inst {Œì Œ£ œÑ} (Œπ : SymInstance Œ£) (Œ¥ŒìŒ£ : SymbolicLocalStore Œì Œ£) (e : Exp Œì œÑ) :
      eval e (inst Œπ Œ¥ŒìŒ£) = inst Œπ (symbolic_eval_exp Œ¥ŒìŒ£ e).
    Proof.
      induction e; cbn; repeat f_equal; auto.
      { unfold inst; cbn. now rewrite env_lookup_map. }
      2: {
        induction es as [|eb n es IHes]; cbn in *.
        { reflexivity. }
        { destruct X as [-> Heqs].
          change (inst_term ?Œπ ?t) with (inst Œπ t).
          destruct (inst Œπ (symbolic_eval_exp Œ¥ŒìŒ£ eb));
            cbn; f_equal; auto.
        }
      }
      all: induction es; cbn in *; destruct_conjs; f_equal; auto.
    Qed.

    Lemma bapprox_eval_exp {Œì Œ£ œÑ} (e : Exp Œì œÑ) (Œπ : SymInstance Œ£) :
      bapprox Œπ (dmut_eval_exp e) (scmut_eval_exp e).
    Proof.
      unfold dmut_eval_exp, scmut_eval_exp, dmut_gets_local, dmut_gets, scmut_gets_local, scmut_state_local.
      apply bapprox_state. intros. destruct s1. cbn. f_equal.
      now rewrite eval_exp_inst.
    Qed.

    Lemma bapprox_pushpop {AT A} `{InstLaws AT A} {Œì1 Œì2 x œÉ Œ£} (Œπ : SymInstance Œ£) (a : Term Œ£ œÉ)
      (dm : DynamicMutator (Œì1 ‚ñª (x :: œÉ)) (Œì2 ‚ñª (x :: œÉ)) AT Œ£) (dm_dcl : dmut_dcl dm)
      (sm : SCMut (Œì1 ‚ñª (x :: œÉ)) (Œì2 ‚ñª (x :: œÉ)) A) :
      bapprox Œπ dm sm ->
      bapprox Œπ (dmut_pushpop a dm) (scmut_pushpop (inst Œπ a) sm).
    Proof.
      intros Hap. unfold dmut_pushpop, scmut_pushpop.
      apply bapprox_bind_right; auto.
      apply dmut_bind_left_dcl; auto.
      apply dmut_pop_local_dcl.
      unfold
        dmut_push_local, dmut_modify_local, dmut_state_local,
        scmut_push_local, scmut_modify_local, scmut_state_local.
      apply bapprox_state. destruct s1 as [Œ¥1 h1]; intros. cbn.
      f_equal. f_equal. subst. now rewrite <- inst_subst.
      apply bapprox_bind_left; eauto.
      apply dmut_pop_local_dcl.
      unfold
        dmut_pop_local, dmut_modify_local, dmut_state_local,
        scmut_pop_local, scmut_modify_local, scmut_state_local.
      apply bapprox_state. destruct s1 as [Œ¥1 h1]; intros. cbn.
      f_equal. f_equal. subst. now destruct (snocView Œ¥1).
    Qed.

    Lemma bapprox_pushspops {AT A} `{InstLaws AT A} {Œì1 Œì2 Œî Œ£} (Œπ : SymInstance Œ£)
      (dm : DynamicMutator (Œì1 ‚ñª‚ñª Œî) (Œì2 ‚ñª‚ñª Œî) AT Œ£) (dm_dcl : dmut_dcl dm)
      (sm : SCMut (Œì1 ‚ñª‚ñª Œî) (Œì2 ‚ñª‚ñª Œî) A) (Hap : bapprox Œπ dm sm) :
      forall (Œ¥__sym : SymbolicLocalStore Œî Œ£) (Œ¥__sc : LocalStore Œî),
        Œ¥__sc = inst Œπ Œ¥__sym ->
        bapprox Œπ (dmut_pushspops Œ¥__sym dm) (scmut_pushspops Œ¥__sc sm).
    Proof. Admitted.

    Lemma bapprox_exec {Œì œÉ} (s : Stm Œì œÉ) :
      forall Œ£ (Œπ : SymInstance Œ£),
        bapprox Œπ (dmut_exec s) (scmut_exec s).
    Proof.
      induction s; cbn [dmut_exec scmut_exec]; intros Œ£ Œπ.
      - unfold bapprox. cbn. auto.
      - now apply bapprox_eval_exp.
      - apply bapprox_bind; auto. admit.
        intros a. apply bapprox_pushpop; auto.
        apply dmut_exec_dcl; auto.
      - apply bapprox_pushspops;
          rewrite ?inst_lift;
          auto using dmut_exec_dcl.
      - apply bapprox_bind; auto. admit.
        intros a.
        apply bapprox_bind_right; auto.
        apply dmut_pure_dcl.
        unfold
          dmut_modify_local, dmut_state_local,
          scmut_modify_local, scmut_state_local.
        apply bapprox_state.
        destruct s1 as [Œ¥1 h1]; intros * ->; cbn.
        f_equal. f_equal. rewrite <- inst_subst.
        unfold inst at 1; cbn.
        now rewrite env_map_update.
        now apply bapprox_pure.
      - destruct (CEnv f).
        + apply bapprox_bind; auto. admit. admit.
          intros ?. apply bapprox_call.
        + admit.
      - apply bapprox_bind. admit.
        { apply bapprox_state. destruct s1; cbn; auto. }
        intros Œ¥0. apply bapprox_bind_right.
        apply dmut_bind_left_dcl. apply dmut_exec_dcl.
        { apply dmut_state_dcl.
          destruct s1, s2; intros ? ? -> Heqs HeqŒ∂; inversion Heqs; cbn in *.
          rewrite ?inst_subst. f_equal. f_equal; congruence. }
        { apply bapprox_state. destruct s1; cbn; intros.
          now rewrite inst_subst, inst_lift. }
        admit.
      - apply bapprox_bind. admit. admit. intros args.
        apply bapprox_call.
      - admit.
      - apply bapprox_bind_right; auto. apply dmut_exec_dcl.
      - apply bapprox_bind. admit.
        apply bapprox_eval_exp.
        intros t. admit.
      - apply bapprox_block.
      - admit.
      - apply bapprox_bind. admit.
        apply bapprox_eval_exp.
        intros t. apply bapprox_match_sum. admit. admit.
        + intros ?. apply bapprox_pushpop; auto using dmut_exec_dcl.
        + intros ?. apply bapprox_pushpop; auto using dmut_exec_dcl.
      - apply bapprox_bind. admit.
        apply bapprox_eval_exp.
        intros t. apply bapprox_match_pair. admit.
        intros ? ?. apply bapprox_pushspops; auto using dmut_exec_dcl.
      - apply bapprox_bind. admit.
        apply bapprox_eval_exp.
        intros t. admit.
      - admit.
      - admit.
      - admit.
      - apply (bapprox_angelic (AT := fun Œ£ => Term Œ£ œÑ)).
        intros t. apply bapprox_bind_right. admit.
        (* apply bapprox_consume_chunk. *)
        admit.
        apply bapprox_bind_right. apply dmut_pure_dcl.
        apply (bapprox_produce_chunk (chunk_ptsreg reg t)).
        now apply bapprox_pure.
      - apply bapprox_bind. admit.
        apply bapprox_eval_exp.
        intros t.
        apply (bapprox_angelic (AT := fun Œ£ => Term Œ£ œÑ)).
        intros t'. apply bapprox_bind_right. admit.
        (* apply bapprox_consume_chunk. *)
        admit.
        apply bapprox_bind_right. apply dmut_pure_dcl.
        apply (bapprox_produce_chunk (chunk_ptsreg reg t)).
        now apply bapprox_pure.
      - admit.
      - admit.
    Admitted.

    Lemma bapprox_contract {Œì œÑ} (c : SepContract Œì œÑ) (s : Stm Œì œÑ) (Œπ : SymInstance (sep_contract_logic_variables c)) :
      bapprox Œπ (@dmut_contract Œì œÑ c s) (@scmut_contract Œì œÑ c s Œπ).
    Proof.
      unfold dmut_contract, scmut_contract; destruct c as [Œ£ Œ¥ pre result post]; cbn in *.
      apply bapprox_bind_right. admit.
      apply bapprox_produce.
      apply bapprox_bind. admit.
      apply bapprox_exec.
      intros res.
      eapply bapprox_sub; eauto.
      rewrite inst_sub_snoc, inst_sub_id.
      (* apply bapprox_consume. *)
    Admitted.

    Lemma symbolic_sound {Œì œÑ} (c : SepContract Œì œÑ) (body : Stm Œì œÑ) :
      ValidContractNoEvar c body ->
      ValidContractSCMut c body.
    Proof.
      unfold ValidContractNoEvar, ValidContractSCMut. intros Hwp.
      unfold ForallNamed in Hwp. rewrite Forall_forall in Hwp.
      intros Œπ. cbn. specialize (Hwp Œπ).
      pose proof (bapprox_contract c body) as H.
      specialize (H Œπ _ (sub_id _) nil Œπ (fun _ _ => True)).
      specialize (H (symbolicstate_initial (sep_contract_localstore c))).
      rewrite inst_sub_id in H. inster H by constructor.
      rewrite outcome_satisfy_map. apply H. clear H.
      unfold dmut_contract_outcome in Hwp.
    Admitted.

    (* Print Assumptions dmut_wp_assume_formula. *)
    (* Print Assumptions dmut_wp_bind. *)
    (* Print Assumptions dmut_wp_bind_right. *)
    (* Print Assumptions dmut_wp_equiv. *)
    (* Print Assumptions dmut_wp_fmap. *)
    (* Print Assumptions dmut_wp_fresh. *)
    (* Print Assumptions dmut_wp_match_pair. *)
    (* Print Assumptions dmut_wp_match_sum. *)
    (* Print Assumptions dmut_wp_pair. *)
    (* Print Assumptions dmut_wp_pure. *)
    (* Print Assumptions dmut_wp_sub. *)

    (* Print Assumptions dmut_pure_dcl. *)
    (* Print Assumptions dmut_fresh_dcl. *)
    (* Print Assumptions dmut_arrow_dcl_specialize. *)
    (* Print Assumptions dmut_arrow_dcl_specialize. *)
    (* Print Assumptions dmut_bind_dcl. *)
    (* Print Assumptions dmut_bind_right_dcl. *)

    (* Print Assumptions symbolic_sound. *)

  End TwoPointOSoundness.

  Section Leftovers.

    Lemma subst_lookup {Œì Œ£ Œ£' x œÉ} (xInŒì : (x ‚à∂ œÉ)%ctx ‚àà Œì) (Œ∂ : Sub Œ£ Œ£') (Œ¥ : SymbolicLocalStore Œì Œ£) :
      (subst Œ∂ (Œ¥ ‚Äº x)%exp = (subst Œ∂ Œ¥ ‚Äº x)%exp).
    Proof.
      unfold subst at 2, subst_localstore, SubstEnv.
      now rewrite env_lookup_map.
    Qed.

    Lemma subst_symboliceval {Œì œÑ Œ£ Œ£'} (e : Exp Œì œÑ) (Œ∂ : Sub Œ£ Œ£') (Œ¥ : SymbolicLocalStore Œì Œ£) :
      subst (T := fun Œ£ => Term Œ£ _) Œ∂ (symbolic_eval_exp Œ¥ e) = symbolic_eval_exp (subst Œ∂ Œ¥) e.
    Proof.
      induction e; cbn; f_equal; auto.
      { now rewrite (subst_lookup xInŒì). }
      all: induction es; cbn in *; destruct_conjs; f_equal; auto.
    Qed.

  End Leftovers.

End Soundness.
