(******************************************************************************)
(* Copyright (c) 2019 Steven Keuchel                                          *)
(* All rights reserved.                                                       *)
(*                                                                            *)
(* Redistribution and use in source and binary forms, with or without         *)
(* modification, are permitted provided that the following conditions are     *)
(* met:                                                                       *)
(*                                                                            *)
(* 1. Redistributions of source code must retain the above copyright notice,  *)
(*    this list of conditions and the following disclaimer.                   *)
(*                                                                            *)
(* 2. Redistributions in binary form must reproduce the above copyright       *)
(*    notice, this list of conditions and the following disclaimer in the     *)
(*    documentation and/or other materials provided with the distribution.    *)
(*                                                                            *)
(* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS        *)
(* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  *)
(* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR *)
(* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR          *)
(* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *)
(* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *)
(* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *)
(* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *)
(* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *)
(* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *)
(* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *)
(******************************************************************************)

From Coq Require Import
     Bool.Bool
     Program.Equality
     Program.Tactics
     ZArith.ZArith
     Strings.String
     Classes.Morphisms
     Classes.Morphisms_Prop
     Classes.Morphisms_Relations.

From Equations Require Import
     Equations.

From MicroSail Require Import
     Sep.Spec
     Sep.Logic
     Sep.Hoare
     Syntax
     Tactics
     Symbolic.Mutator.
From MicroSail Require Import
     SemiConcrete.Mutator
     SemiConcrete.Outcome
     SemiConcrete.Sound.

Set Implicit Arguments.

Import CtxNotations.
Import EnvNotations.

Module Soundness
       (Import termkit : TermKit)
       (Import progkit : ProgramKit termkit)
       (Import assertkit : AssertionKit termkit progkit)
       (Import contractkit : SymbolicContractKit termkit progkit assertkit).
  Module MUT := Mutators termkit progkit assertkit contractkit.
  Import MUT.
  Module LOG := ProgramLogic termkit progkit assertkit contractkit.
  Import LOG.
  Module SCMUT := SemiConcrete.Sound.Soundness termkit progkit assertkit contractkit.
  Import SCMUT.MUT.

  Module DynMutV1Soundness.

    Import DynMutV1.

    Global Instance inst_heap : Inst SymbolicHeap SCHeap :=
      instantiate_list.
    Global Instance instlaws_heap : InstLaws SymbolicHeap SCHeap.
    Proof. apply instantiatelaws_list. Qed.

    (* Relate two symbolic instances at different points during execution. This
       essentially encodes a preorder on the total space { Œ£ & SymInstance Œ£ },
       which encodes that Œπ2 is a future of Œπ1, i.e. it is derived by compatible
       for existing variables and values for new universal variables. *)
    Definition syminstance_rel {Œ£1 Œ£2} (Œ∂ : Sub Œ£1 Œ£2) (Œπ1 : SymInstance Œ£1) (Œπ2 : SymInstance Œ£2) : Prop :=
      inst Œπ2 Œ∂ = Œπ1.
    Hint Unfold syminstance_rel : core.

    Lemma syminstance_rel_refl {Œ£} (Œπ : SymInstance Œ£) :
      syminstance_rel (sub_id Œ£) Œπ Œπ.
    Proof. apply inst_sub_id. Qed.

    Lemma syminstance_rel_refl_inv {Œ£} (Œπ1 Œπ2 : SymInstance Œ£) :
      syminstance_rel (sub_id Œ£) Œπ1 Œπ2 -> Œπ2 = Œπ1.
    Proof. unfold syminstance_rel. now rewrite inst_sub_id. Qed.

    Lemma syminstance_rel_snoc {Œ£1 Œ£2 x œÑ} (Œ∂ : Sub Œ£1 Œ£2) (Œπ1 : SymInstance Œ£1) Œπ2 :
      forall t v,
        syminstance_rel (env_snoc Œ∂ (x,œÑ) t) (env_snoc Œπ1 (x,œÑ) v) Œπ2 <->
        syminstance_rel Œ∂ Œπ1 Œπ2 /\ v = inst Œπ2 t.
    Proof.
      unfold syminstance_rel. intros. split.
      - cbn; intros.
        now dependent elimination H.
      - cbn; intros []; subst; now cbn.
    Qed.

    Lemma syminstance_rel_comp {Œ£0 Œ£1 Œ£2} (Œ∂1 : Sub Œ£0 Œ£1) (Œ∂2 : Sub Œ£1 Œ£2)
          (Œπ0 : SymInstance Œ£0) (Œπ2 : SymInstance Œ£2):
      syminstance_rel (sub_comp Œ∂1 Œ∂2) Œπ0 Œπ2 <->
      syminstance_rel Œ∂1 Œπ0 (inst Œπ2 Œ∂2).
    Proof. unfold syminstance_rel. now rewrite <- inst_subst. Qed.

    Lemma syminstance_rel_trans {Œ£0 Œ£1 Œ£2} {Œ∂1 : Sub Œ£0 Œ£1} {Œ∂2 : Sub Œ£1 Œ£2}
          {Œπ0 : SymInstance Œ£0} {Œπ1 : SymInstance Œ£1} {Œπ2 : SymInstance Œ£2} :
      syminstance_rel Œ∂1 Œπ0 Œπ1 -> syminstance_rel Œ∂2 Œπ1 Œπ2 ->
      syminstance_rel (sub_comp Œ∂1 Œ∂2) Œπ0 Œπ2.
    Proof. intros. apply syminstance_rel_comp. congruence. Qed.

    Lemma syminstance_rel_wk1 {Œ£ : NCtx ùë∫ Ty} {x œÑ} (Œπ : SymInstance Œ£) (v : Lit œÑ) :
      syminstance_rel sub_wk1 Œπ (Œπ ‚ñ∫ ((x, œÑ) ‚Ü¶ v)).
    Proof. apply inst_sub_wk1. Qed.

    Lemma syminstance_rel_up {Œ£1 Œ£2 x œÑ} (Œ∂ : Sub Œ£1 Œ£2) (Œπ1 : SymInstance Œ£1) Œπ2 :
      forall v,
        syminstance_rel (sub_up1 Œ∂) (env_snoc Œπ1 (x,œÑ) v) (env_snoc Œπ2 (x,œÑ) v) <->
        syminstance_rel Œ∂ Œπ1 Œπ2.
    Proof.
      unfold syminstance_rel. intros v.
      change (inst (Œπ2 ‚ñ∫ (x :: œÑ ‚Ü¶ v)) (sub_comp Œ∂ sub_wk1) ‚ñ∫ (x :: œÑ ‚Ü¶ v) =
              Œπ1 ‚ñ∫ (x :: œÑ ‚Ü¶ v) <-> inst Œπ2 Œ∂ = Œπ1).
      unfold sub_comp. rewrite inst_subst, inst_sub_wk1.
      split; intros H.
      - now dependent elimination H.
      - now f_equal.
    Qed.

    (* A relation that links semi-concrete states with symbolic states. This
       simply requires that when instantiating the symbolic state you get the
       semi-concrete one (and the path-condition is true). Note that the
       equality used in the heap instantiation requires the symbolic and the
       semi-concrete executor to be in lock step with respect to the heap: i.e.
       the symbolic executor and the semi-concrete executor need to end up with
       a heap that has the same chunks in the same order. This can be relaxed
       later to allow permutations or even some kind of semantic equivalence. *)
    Definition represents {Œì Œ£} (Œπ : SymInstance Œ£) (s__sym : SymbolicState Œì Œ£) (s__sc : SCState Œì) : Prop :=
      inst                Œπ (symbolicstate_heap s__sym)       = scstate_heap s__sc /\
      inst                Œπ (symbolicstate_localstore s__sym) = scstate_localstore s__sc /\
      inst_pathcondition  Œπ (symbolicstate_pathcondition s__sym).

    (* This is a preservation lemma for state representation. The symbolic
       executor is allwed to add a formula (local assumption) to the
       path-condition if it's true for the current instance Œπ. We only
       need the -> direction I think. *)
    Lemma represents_assume_formula {Œì Œ£} (Œπ : SymInstance Œ£) (s__sym : SymbolicState Œì Œ£) (s__sc : SCState Œì) fml :
      represents Œπ s__sym s__sc /\ inst_formula Œπ fml <->
      represents Œπ (symbolicstate_assume_formula fml s__sym) s__sc.
    Proof.
      unfold represents; destruct s__sym, s__sc; cbn; intuition.
      - rewrite fold_right_1_10_prop; intuition.
      - rewrite fold_right_1_10_prop in H2; intuition.
      - rewrite fold_right_1_10_prop in H2; intuition.
    Qed.

    Lemma represents_produce_chunk {Œì Œ£} (Œπ : SymInstance Œ£) (c1 : Chunk Œ£) (c2 : SCChunk)
          (s__sym : SymbolicState Œì Œ£) (s__sc : SCState Œì) :
      represents Œπ s__sym s__sc /\ c2 = inst Œπ c1 <->
      represents Œπ (symbolicstate_produce_chunk c1 s__sym) (scstate_produce_chunk c2 s__sc).
    Proof.
      unfold represents; destruct s__sym, s__sc; cbn - [inst].
      change (inst Œπ (cons c1 ?h)) with (cons (inst Œπ c1) (inst Œπ h)).
      split; intros H; destruct_propositional H; subst; intuition.
      now dependent elimination H1.
    Qed.

    Lemma inst_subst_formula {Œ£1 Œ£2} (Œπ : SymInstance Œ£2) (Œ∂ : Sub Œ£1 Œ£2) (fml : Formula Œ£1) :
      inst_formula (inst Œπ Œ∂) fml <-> inst_formula Œπ (subst Œ∂ fml).
    Proof. destruct fml; cbn - [inst]; now rewrite !inst_subst. Qed.

    Lemma inst_subst_pathcondition {Œ£1 Œ£2} (Œπ : SymInstance Œ£2) (Œ∂ : Sub Œ£1 Œ£2) (pc : PathCondition Œ£1) :
      inst_pathcondition (inst Œπ Œ∂) pc <-> inst_pathcondition Œπ (subst Œ∂ pc).
    Proof.
      induction pc; cbn - [inst].
      - reflexivity.
      - rewrite fold_right_1_10_prop.
        rewrite fold_right_1_10_prop.
        rewrite inst_subst_formula.
        apply and_iff_compat_l, IHpc.
    Qed.

    (* This is another preservation lemma. This one covers every state change in
       the symbolic executor that is implemented via a universal variable
       substitution, i.e. local equality assumptions that are substituted right
       away and allocation of fresh universal variables. The converse <- also
       holds, but has very strong assumptions. A more general relation
       between symbolic states is encoded by state_geq below. *)
    Lemma represents_rel {Œì Œ£0 Œ£1} (Œ∂1 : Sub Œ£0 Œ£1) (Œπ0 : SymInstance Œ£0) (Œπ1 : SymInstance Œ£1) :
      syminstance_rel Œ∂1 Œπ0 Œπ1 ->
      forall (s__sym : SymbolicState Œì Œ£0) (s__sc : SCState Œì),
        represents Œπ0 s__sym s__sc <->
        represents Œπ1 (subst Œ∂1 s__sym) s__sc.
    Proof.
      unfold syminstance_rel, represents; intros. subst.
      destruct s__sym as [pc Œ¥__sym h__sym], s__sc as [Œ¥__sc h__sc];
        cbn - [inst inst_pathcondition].
      now rewrite !inst_subst, inst_subst_pathcondition.
    Qed.

    Definition ResultProperty Œì A Œ£ :=
      DynamicMutatorResult Œì A Œ£ -> Prop.

    Definition state_geq {Œì Œ£0 Œ£1} (Œ∂1 : Sub Œ£0 Œ£1)
      (s__sym0 : SymbolicState Œì Œ£0) (s__sym1 : SymbolicState Œì Œ£1) : Prop :=
      forall (Œπ0 : SymInstance Œ£0) (Œπ1 : SymInstance Œ£1),
        syminstance_rel Œ∂1 Œπ0 Œπ1 ->
        forall (s__sc : SCState Œì),
          represents Œπ1 s__sym1 s__sc ->
          represents Œπ0 s__sym0 s__sc.

    Lemma state_geq_subst {Œì Œ£0 Œ£1} (Œ∂1 : Sub Œ£0 Œ£1) (s0 : SymbolicState Œì Œ£0) (s1 : SymbolicState Œì Œ£1) :
      s1 = subst Œ∂1 s0 ->
      state_geq Œ∂1 s0 s1.
    Proof. intros -> ? ? ? ?. now apply represents_rel. Qed.

    Definition dmutres_geq_syn {Œì A Œ£} `{Subst A} (r1 r2 : DynamicMutatorResult Œì A Œ£) : Prop :=
      match r1 , r2 with
      | MkDynMutResult Œ∂1 a1 s1, MkDynMutResult Œ∂2 a2 s2 =>
        exists Œ∂12,
        Œ∂2 = sub_comp Œ∂1 Œ∂12 /\
        a2 = subst Œ∂12 a1 /\
        s2 = subst Œ∂12 s1
      end.

    Definition dmutres_geq_sem {Œì A V Œ£} {instA : Inst A V} (r1 r2 : DynamicMutatorResult Œì A Œ£) : Prop :=
      match r1 , r2 with
      | MkDynMutResult Œ∂1 a1 s1, MkDynMutResult Œ∂2 a2 s2 =>
        exists Œ∂12,
        forall Œπ1 Œπ2,
          syminstance_rel Œ∂12 Œπ1 Œπ2 ->
          forall s__sc,
            represents Œπ2 s2 s__sc ->
            represents Œπ1 s1 s__sc /\
            inst Œπ1 a1 = inst Œπ2 a2 /\
            inst Œπ1 Œ∂1 = inst Œπ2 Œ∂2
      end.

    Lemma dmutres_geq_syn_sem {Œì A V Œ£} `{InstLaws A V} :
      forall r1 r2 : DynamicMutatorResult Œì A Œ£,
        dmutres_geq_syn r1 r2 ->
        dmutres_geq_sem r1 r2.
    Proof.
      intros [Œ£1 Œ∂1 a1 s1] [Œ£2 Œ∂2 a2 s2] [Œ∂12 (-> & -> & ->)]; cbn - [inst].
      exists Œ∂12. intros ? ? <- ? rep.
      split. revert rep. apply represents_rel. reflexivity.
      unfold sub_comp. rewrite ?inst_subst. auto.
    Qed.

    Global Instance dmutres_geq_sem_preorder {Œì A V Œ£} `{instLA : InstLaws A V} : PreOrder (@dmutres_geq_sem Œì A V Œ£ _).
    Proof.
      constructor.
      - intros [Œ£1 Œ∂1 a1 s]. cbn - [inst]. exists (sub_id _).
        intros * ->%syminstance_rel_refl_inv. auto.
      - intros [Œ£1 Œ∂1 a1 s1] [Œ£2 Œ∂2 a2 s2] [Œ£3 Œ∂3 a3 s3]. cbn - [inst].
        intros [Œ∂12] [Œ∂23].
        exists (sub_comp Œ∂12 Œ∂23).
        intros Œπ1 Œπ3 rel13 sc rep3.
        apply syminstance_rel_comp in rel13.
        remember (inst Œπ3 Œ∂23) as Œπ2.
        assert (syminstance_rel Œ∂23 Œπ2 Œπ3).
        now unfold syminstance_rel.
        specialize (H3 _ _ H4 _ rep3). destruct_conjs.
        specialize (H2 _ _ rel13 _ H3). destruct_conjs.
        split; auto. split; congruence.
    Qed.

    Lemma dmutres_geq_sem_pre_comp {A AV} {instA : Inst A AV} {Œì Œ£1 Œ£2 Œ£3}
          (Œ∂2 : Sub Œ£1 Œ£2) (a2 : A Œ£2) (s2 : SymbolicState Œì Œ£2)
          (Œ∂3 : Sub Œ£1 Œ£3) (a3 : A Œ£3) (s3 : SymbolicState Œì Œ£3) :
      forall Œ£0 (Œ∂1 : Sub Œ£0 Œ£1),
        dmutres_geq_sem
          {| dmutres_context := Œ£2; dmutres_substitution := Œ∂2; dmutres_result_value := a2; dmutres_result_state := s2 |}
          {| dmutres_context := Œ£3; dmutres_substitution := Œ∂3; dmutres_result_value := a3; dmutres_result_state := s3 |} ->
        dmutres_geq_sem
          {| dmutres_context := Œ£2; dmutres_substitution := sub_comp Œ∂1 Œ∂2; dmutres_result_value := a2; dmutres_result_state := s2 |}
          {| dmutres_context := Œ£3; dmutres_substitution := sub_comp Œ∂1 Œ∂3; dmutres_result_value := a3; dmutres_result_state := s3 |}.
    Proof.
      intros ? ? [Œ∂23 H]. exists Œ∂23.
      intros ? ? Hrel. specialize (H _ _ Hrel).
      intros ? Hrep. specialize (H _ Hrep).
      unfold sub_comp. rewrite ?inst_subst.
      intuition congruence.
    Qed.

    Definition resultprop_specialize {Œì A Œ£1 Œ£2} (Œ∂ : Sub Œ£1 Œ£2) :
      ResultProperty Œì A Œ£1 -> ResultProperty Œì A Œ£2 :=
      fun p r => p (cosubst_dmutres Œ∂ r).

    Definition resultprop_downwards_closed {Œì AT Œ£ A} `{Inst AT A} (p : ResultProperty Œì AT Œ£) : Prop :=
      forall (r1 r2 : DynamicMutatorResult Œì AT Œ£),
        dmutres_geq_sem r1 r2 -> p r1 -> p r2.

    Lemma resultprop_specialize_dcl {Œì A AV Œ£1 Œ£2} `{Inst A AV} (Œ∂ : Sub Œ£1 Œ£2) (POST : ResultProperty Œì A Œ£1) (POST_dcl : resultprop_downwards_closed POST) :
      resultprop_downwards_closed (resultprop_specialize Œ∂ POST).
    Proof.
      unfold resultprop_downwards_closed, resultprop_specialize.
      intros [Œ£3 Œ∂3 a3 s3] [Œ£4 Œ∂4 a4 s4] [Œ∂34]. apply POST_dcl. exists Œ∂34.
      intros ? ? Hrel ? Hrep. specialize (H0 _ _ Hrel _ Hrep).
      unfold sub_comp. rewrite ?inst_subst.
      intuition congruence.
    Qed.

    Definition StateProperty Œì A Œ£ :=
      forall Œ£1, Sub Œ£ Œ£1 -> A Œ£1 -> SymbolicState Œì Œ£1 -> Prop.

    Definition stateprop_specialize {Œì A Œ£1 Œ£2} (Œ∂ : Sub Œ£1 Œ£2) (p: StateProperty Œì A Œ£1) :
      StateProperty Œì A Œ£2 := fun Œ£3 Œ∂3 => p Œ£3 (sub_comp Œ∂ Œ∂3).

    Definition stateprop_impl {Œì A Œ£} (P Q : StateProperty Œì A Œ£) : Prop :=
      forall Œ£1 (Œ∂ : Sub Œ£ Œ£1) (a : A Œ£1) (s : SymbolicState Œì Œ£1),
        P Œ£1 Œ∂ a s -> Q Œ£1 Œ∂ a s.

    Definition stateprop_downwards_closed {Œì Œ£ A AV} `{Inst A AV} (p : StateProperty Œì A Œ£) : Prop :=
      forall Œ£1 (Œ∂1 : Sub Œ£ Œ£1) a1 s1 Œ£2 (Œ∂2 : Sub Œ£ Œ£2) a2 s2,
        dmutres_geq_sem (MkDynMutResult Œ∂1 a1 s1) (MkDynMutResult Œ∂2 a2 s2) ->
        p Œ£1 Œ∂1 a1 s1 -> p Œ£2 Œ∂2 a2 s2.

    Local Notation "[ Œπ ] x == y" := (inst Œπ x = inst Œπ y) (at level 50).

    (* Read: If œÇ is equivalent to t in Œπ, then substituting t for œÇ is equivalent to the identity. *)
    Lemma inst_single_shift {Œ£ œÇ œÉ} (œÇInŒ£ : œÇ :: œÉ ‚àà Œ£) (t : Term (Œ£ - (œÇ :: œÉ)) œÉ) Œπ :
      [ Œπ ] term_var œÇ == subst (sub_shift œÇInŒ£) t ->
      [ Œπ ] sub_comp (sub_single œÇInŒ£ t) (sub_shift œÇInŒ£) == sub_id _.
    Proof.
      intros H.
      apply env_lookup_extensional; cbn.
      intros [] bIn.
      unfold sub_id, sub_comp.
      unfold subst, SubstEnv.
      rewrite ?env_lookup_map, ?env_lookup_tabulate.
      pose proof (occurs_check_var_spec œÇInŒ£ bIn).
      destruct (occurs_check_var œÇInŒ£ bIn) eqn:?.
      - dependent elimination e. cbn in H0. subst.
        rewrite lookup_sub_single_eq. symmetry. exact H.
      - f_equal.
        destruct H0. subst bIn.
        rewrite lookup_sub_single_neq.
        cbn. unfold sub_shift.
        rewrite env_lookup_tabulate.
        reflexivity.
    Qed.

    (* Lemma inst_pathcondition_swap {Œ£} (Œπ : SymInstance Œ£) a b pc : *)
    (*   inst_pathcondition Œπ (a :: b :: pc)%list -> *)
    (*   inst_pathcondition Œπ (b :: a :: pc)%list. *)
    (* Proof. *)
    (*   intros Hpc. *)
    (*   destruct Hpc as [Ha Hpc]. *)
    (*   destruct Hpc as [Hb Hpc]. *)
    (*   split. assumption. *)
    (*   split. assumption. *)
    (*   assumption. *)
    (* Qed. *)

    Lemma dmutres_try_assume_eq_spec {Œì Œ£ œÉ} (s__sym : SymbolicState Œì Œ£) (t1 t2 : Term Œ£ œÉ)
      (POST : ResultProperty Œì Unit Œ£) (POST_dcl : resultprop_downwards_closed POST) :
      OptionSpec
        (fun r => POST r <->
                  POST (MkDynMutResult
                          (sub_id Œ£)
                          tt
                          (symbolicstate_assume_formula (formula_eq t1 t2) s__sym)))
        True
        (dmutres_try_assume_eq s__sym t1 t2).
    Proof.
      destruct t1; cbn; try (constructor; auto; fail).
      destruct (occurs_check œÇInŒ£ t2) eqn:?; constructor; auto.
      apply (@occurs_check_sound _ _ (@OccursCheckTerm _)) in Heqo;
      auto with typeclass_instances. subst t2.
      split.
      - apply POST_dcl. exists (sub_shift œÇInŒ£).
        intros * rel12 ? rep2.
        apply represents_assume_formula in rep2. destruct rep2.
        apply inst_single_shift in H0.
        rewrite inst_sub_id in H0.
        split.
        + revert H. apply represents_rel.
          revert rel12. intros <-.
          now apply syminstance_rel_comp.
        + split; auto.
          revert rel12. intros <-.
          now rewrite inst_sub_id, <- ?inst_subst.
      - apply POST_dcl. exists (sub_single œÇInŒ£ t).
        intros * <- ? rep2.
        apply (represents_rel eq_refl) in rep2.
        rewrite inst_sub_id. split; auto.
        apply represents_assume_formula. split; auto.
        cbn - [inst].
        rewrite <- ?inst_subst.
        rewrite <- subst_sub_comp.
        rewrite sub_comp_shift_single, subst_sub_id.
        cbn - [inst].
        rewrite lookup_sub_single_eq.
        reflexivity.
    Qed.

    Lemma dmutres_assume_formula_spec {Œì Œ£} (s__sym : SymbolicState Œì Œ£) (fml : Formula Œ£)
      (POST : ResultProperty Œì Unit Œ£) (POST_dcl : resultprop_downwards_closed POST) :
      POST (dmutres_assume_formula s__sym fml) <->
      POST (MkDynMutResult
              (sub_id Œ£)
              tt
              (symbolicstate_assume_formula fml s__sym)).
    Proof.
      split.
      - destruct fml; cbn; auto.
        destruct (dmutres_try_assume_eq_spec s__sym t1 t2 POST_dcl). apply H. clear H.
        destruct (dmutres_try_assume_eq_spec s__sym t2 t1 POST_dcl); auto.
        intros Hpost. apply H in Hpost. clear a H. revert Hpost.
        apply POST_dcl. exists (sub_id _). intros ? ? <- ? Hrep.
        rewrite ?inst_sub_id; split; auto.
        apply represents_assume_formula in Hrep. destruct Hrep as [Hrep Hfml].
        apply represents_assume_formula. split; auto.
        revert Hfml; now cbn.
      - destruct fml; cbn; auto.
        destruct (dmutres_try_assume_eq_spec s__sym t1 t2 POST_dcl). apply H. clear H.
        destruct (dmutres_try_assume_eq_spec s__sym t2 t1 POST_dcl); auto.
        intros Hpost. apply H. clear a H. revert Hpost.
        apply POST_dcl. exists (sub_id _). intros ? ? <- ? Hrep.
        rewrite ?inst_sub_id; split; auto.
        apply represents_assume_formula in Hrep. destruct Hrep as [Hrep Hfml].
        apply represents_assume_formula. split; auto.
        revert Hfml; now cbn.
    Qed.

    Lemma subst_symbolicstate_assume_formula {Œì Œ£1 Œ£2} (Œ∂ : Sub Œ£1 Œ£2)
          (f : Formula Œ£1) (s : SymbolicState Œì Œ£1) :
      subst Œ∂ (symbolicstate_assume_formula f s) =
      symbolicstate_assume_formula (subst Œ∂ f) (subst Œ∂ s).
    Proof. now destruct s. Qed.

    (* These should be kept abstract in the rest of the proof. If you need some
       property, add a lemma above. *)
    Local Opaque inst_chunk.
    Local Opaque inst_heap.
    Local Opaque inst_pathcondition.
    Local Opaque instantiate_env.
    Local Opaque instantiate_list.
    Local Opaque represents.
    Local Opaque symbolicstate_assume_formula.
    Local Opaque symbolicstate_produce_chunk.
    Local Opaque dmutres_assume_formula.

    Definition scmut_wp {Œì1 Œì2 A}
      (m : SCMut Œì1 Œì2 A)
      (POST : A -> SCState Œì2 -> Prop)
      (s1 : SCState Œì1) : Prop :=
      outcome_satisfy (m s1) (fun r => POST (scmutres_value r) (scmutres_state r)).

    Lemma scmut_wp_bind {Œì1 Œì2 Œì3 A B} (ma : SCMut Œì1 Œì2 A) (f : A -> SCMut Œì2 Œì3 B)
          (POST : B -> SCState Œì3 -> Prop) :
      forall s1 : SCState Œì1,
        scmut_wp (scmut_bind ma f) POST s1 <->
        scmut_wp ma (fun a => scmut_wp (f a) POST) s1.
    Proof.
      unfold SCMut, scmut_bind, scmut_wp in *; cbn; intros.
      now rewrite outcome_satisfy_bind.
    Qed.

    Definition dmut_wp {Œì1 Œì2 Œ£0 A}
      (m : DynamicMutator Œì1 Œì2 A Œ£0)
      (POST : StateProperty Œì2 A Œ£0)
      (s1 : SymbolicState Œì1 Œ£0) : Prop :=
      forall Œ£1 (Œ∂1 : Sub Œ£0 Œ£1),
        outcome_satisfy
          (m Œ£1 Œ∂1 (subst Œ∂1 s1))
          (fun '(@MkDynMutResult _ _ _ Œ£2 Œ∂2 a2 s2) =>
             POST Œ£2 (sub_comp Œ∂1 Œ∂2) a2 s2).

    Lemma dmut_wp_monotonic {Œì1 Œì2 Œ£0 A} (m : DynamicMutator Œì1 Œì2 A Œ£0)
          (P Q : StateProperty Œì2 A Œ£0) (HYP : stateprop_impl P Q) :
      forall (s1 : SymbolicState Œì1 Œ£0),
        dmut_wp m P s1 -> dmut_wp m Q s1.
    Proof.
      unfold dmut_wp; cbn; intros s1 H Œ£1 Œ∂1.
      specialize (H Œ£1 Œ∂1). revert H.
      apply outcome_satisfy_monotonic.
      intros [Œ£2 Œ∂2 a2 s2]; cbn.
      intuition.
    Qed.

    Definition stateprop_lift {Œì AT A Œ£} {instA : Inst AT A} (Œπ : SymInstance Œ£) (POST : A -> SCState Œì -> Prop) :
      StateProperty Œì AT Œ£ :=
      fun Œ£1 Œ∂1 v1 s__sym1 =>
        forall Œπ1,
          syminstance_rel Œ∂1 Œπ Œπ1 ->
          forall s__sc1,
            represents Œπ1 s__sym1 s__sc1 ->
            POST (inst Œπ1 v1) s__sc1.

    Lemma stateprop_lift_dcl {Œì AT A Œ£} `{InstLaws AT A} (Œπ1 : SymInstance Œ£) (POST : A -> SCState Œì -> Prop) :
      stateprop_downwards_closed (stateprop_lift Œπ1 POST).
    Proof.
      unfold stateprop_downwards_closed, stateprop_lift.
      intros Œ£3 Œ∂3 a3 s3 Œ£4 Œ∂4 a4 s4 [Œ∂34 Hgeq] Hpost Œπ2 r12 ? ?.
      specialize (Hgeq (inst Œπ2 Œ∂34) Œπ2 eq_refl _ H3). destruct_conjs.
      specialize (Hpost (inst Œπ2 Œ∂34)).
      unfold syminstance_rel in Hpost.
      rewrite H6 in Hpost. specialize (Hpost r12 _ H4).
      rewrite H5 in Hpost. apply Hpost.
    Qed.

    Definition resultprop_lift {Œì AT A Œ£1} {instA : Inst AT A} (Œπ1 : SymInstance Œ£1) (POST : A -> SCState Œì -> Prop) :
      ResultProperty Œì AT Œ£1 :=
      fun dres =>
        match dres with
        | @MkDynMutResult _ _ _ Œ£2 Œ∂2 a2 s2 =>
          stateprop_lift Œπ1 POST Œ∂2 a2 s2
        end.

    Definition resultprop_lift_dcl {Œì AT A Œ£1} `{InstLaws AT A} (Œπ1 : SymInstance Œ£1) (POST : A -> SCState Œì -> Prop) :
      resultprop_downwards_closed (resultprop_lift Œπ1 POST).
    Proof.
      unfold resultprop_downwards_closed, resultprop_lift.
      intros [Œ£3 Œ∂3 a3 s3] [Œ£4 Œ∂4 a4 s4].
      apply stateprop_lift_dcl.
    Qed.

    Definition APPROX Œì1 Œì2 AT A {instA : Inst AT A} : Type :=
      forall Œ£ (Œπ : SymInstance Œ£),
        DynamicMutator Œì1 Œì2 AT Œ£ -> SCMut Œì1 Œì2 A -> Prop.
    Arguments APPROX _ _ _ _ {_}.

    Definition box {Œì1 Œì2 AT A} {instA : Inst AT A} (R : APPROX Œì1 Œì2 AT A) : APPROX Œì1 Œì2 AT A :=
      fun Œ£ Œπ dm sm =>
        forall Œ£1 (Œ∂1 : Sub Œ£ Œ£1) (Œπ1 : SymInstance Œ£1),
          syminstance_rel Œ∂1 Œπ Œπ1 ->
          R Œ£1 Œπ1 (dmut_sub Œ∂1 dm) sm.

    Lemma box_proj {Œì1 Œì2 AT A} {instA : Inst AT A} (R : APPROX Œì1 Œì2 AT A) :
      forall Œ£ (Œπ : SymInstance Œ£) dm sm,
        box R Œπ dm sm -> R _ Œπ dm sm.
    Proof.
      intros ? ? ? ? b.
      unfold box in b.
      inster b by apply syminstance_rel_refl.
      unfold dmut_sub in b.
      (* apply b. *)
    Admitted.

    Definition box_box {Œì1 Œì2 AT A} {instA : Inst AT A} (R : APPROX Œì1 Œì2 AT A) :
      forall Œ£ (Œπ : SymInstance Œ£) dm sm,
        box R Œπ dm sm -> box (box R) Œπ dm sm.
    Proof.
      intros ? ? ? ?. unfold box. intros bb Œ£1 Œ∂1 Œπ1 ? Œ£2 Œ∂2 Œπ2 ?.
      specialize (bb Œ£2 (sub_comp Œ∂1 Œ∂2) Œπ2).
      inster bb by eapply syminstance_rel_trans; eauto.
      (* apply bb. *)
    Admitted.

    Definition approximates {Œì1 Œì2 AT A} {instA : Inst AT A} : APPROX Œì1 Œì2 AT A :=
      fun Œ£ Œπ dm sm =>
        forall (s__sym : SymbolicState Œì1 Œ£) (s__sc : SCState Œì1),
          represents Œπ s__sym s__sc ->
          forall (POST : A -> SCState Œì2 -> Prop),
            dmut_wp dm (stateprop_lift Œπ POST) s__sym ->
            scmut_wp sm POST s__sc.

    Lemma approximates_proj {Œì1 Œì2 AT A} {instA : Inst AT A} {Œ£} (Œπ : SymInstance Œ£)
      (dm : DynamicMutator Œì1 Œì2 AT Œ£) (sm : SCMut Œì1 Œì2 A) :
      box approximates Œπ dm sm -> approximates Œπ dm sm.
    Proof.
      unfold approximates, box. intros.
      inster H by apply syminstance_rel_refl.
      inster H by eauto. apply H. clear H.
      unfold dmut_wp, dmut_sub in *. intros Œ£1 Œ∂1.
      rewrite sub_comp_id_left. apply H1.
    Qed.

    Lemma approximates_box_box {Œì1 Œì2 AT A} {instA : Inst AT A} {Œ£} (Œπ : SymInstance Œ£)
      (dm : DynamicMutator Œì1 Œì2 AT Œ£) (sm : SCMut Œì1 Œì2 A) :
      box approximates Œπ dm sm -> box (box approximates) Œπ dm sm.
    Proof.
      unfold approximates, box, dmut_wp, dmut_sub. intros.
      inster H by eapply syminstance_rel_trans; eauto.
      inster H by eauto. apply H. clear H. intros. now rewrite sub_comp_assoc.
    Qed.

    Lemma approximates_sub {Œì Œ£ Œ£1} (Œ∂1 : Sub Œ£ Œ£1) (Œπ : SymInstance Œ£) (Œπ1 : SymInstance Œ£1)
      (relŒπ1 : syminstance_rel Œ∂1 Œπ Œπ1) (d : DynamicMutator Œì Œì Unit Œ£) (s : SCMut Œì Œì unit) :
      box approximates Œπ d s -> box approximates Œπ1 (dmut_sub Œ∂1 d) s.
    Proof. intros H. eapply approximates_box_box; eauto. Qed.

    Lemma scmut_wp_demonic_binary {Œì1 Œì2 A} (sm1 sm2 : SCMut Œì1 Œì2 A) (s__sc : SCState Œì1) (POST : A -> SCState Œì2 -> Prop) :
      scmut_wp (scmut_demonic_binary sm1 sm2) POST s__sc <->
      scmut_wp sm1 POST s__sc /\ scmut_wp sm2 POST s__sc.
    Proof. unfold scmut_wp, scmut_demonic_binary; cbn; intuition. Qed.

    Lemma dmut_wp_demonic_binary {Œì1 Œì2 Œ£ A} (m1 m2 : DynamicMutator Œì1 Œì2 A Œ£)
      (POST : StateProperty Œì2 A Œ£) (s : SymbolicState Œì1 Œ£) :
        dmut_wp (dmut_demonic_binary m1 m2) POST s <->
        dmut_wp m1 POST s /\ dmut_wp m2 POST s.
    Proof. unfold dmut_wp, dmut_demonic_binary; cbn; intuition. Qed.

    Lemma dmut_wp_sub_demonic_binary {Œì1 Œì2 Œ£ A Œ£1} (Œ∂1 : Sub Œ£ Œ£1) (m1 m2 : DynamicMutator Œì1 Œì2 A Œ£)
      (POST : StateProperty Œì2 A Œ£1) (s : SymbolicState Œì1 Œ£1) :
        dmut_wp (dmut_sub Œ∂1 (dmut_demonic_binary m1 m2)) POST s <->
        dmut_wp (dmut_sub Œ∂1 m1) POST s /\ dmut_wp (dmut_sub Œ∂1 m2) POST s.
    Proof. unfold dmut_wp, dmut_demonic_binary; cbn; intuition. Qed.

    Lemma approximates_demonic_binary {Œì1 Œì2 Œ£} (Œπ : SymInstance Œ£)
          (dm1 dm2 : DynamicMutator Œì1 Œì2 Unit Œ£) (sm1 sm2 : SCMut Œì1 Œì2 unit) :
      box approximates Œπ dm1 sm1 ->
      box approximates Œπ dm2 sm2 ->
      box approximates Œπ (dmut_demonic_binary dm1 dm2) (scmut_demonic_binary sm1 sm2).
    Proof.
      unfold box. intros H1 H2 Œ£1 Œ∂1 Œπ1 H__Œπ.
      specialize (H1 Œ£1 Œ∂1 Œπ1 H__Œπ). specialize (H2 Œ£1 Œ∂1 Œπ1 H__Œπ).
      intros ? ? H__s POST. specialize (H1 _ _ H__s POST). specialize (H2 _ _ H__s POST).
      intros H. apply dmut_wp_sub_demonic_binary in H. destruct H.
      apply scmut_wp_demonic_binary. split; auto.
    Qed.

    Lemma scmut_wp_demonic {Œì1 Œì2 A B} (sm : B -> SCMut Œì1 Œì2 A) (s__sc : SCState Œì1) (POST : A -> SCState Œì2 -> Prop) :
      scmut_wp (scmut_demonic sm) POST s__sc <-> forall v, scmut_wp (sm v) POST s__sc.
    Proof. unfold scmut_wp, scmut_demonic; cbn; intuition. Qed.

    Lemma dmut_wp_demonic {Œì1 Œì2 Œ£ A B} (m : B -> DynamicMutator Œì1 Œì2 A Œ£)
      (POST : StateProperty Œì2 A Œ£) (s : SymbolicState Œì1 Œ£) :
        dmut_wp (dmut_demonic m) POST s <->
        forall b, dmut_wp (m b) POST s.
    Proof. unfold dmut_wp, dmut_demonic; cbn; intuition. Qed.

    Lemma subst_symbolicstate_produce_chunk {Œì Œ£ Œ£1} (Œ∂1 : Sub Œ£ Œ£1) (c : Chunk Œ£) (s : SymbolicState Œì Œ£) :
      subst Œ∂1 (symbolicstate_produce_chunk c s) = symbolicstate_produce_chunk (subst Œ∂1 c) (subst Œ∂1 s).
    Proof. now destruct s. Qed.

    Lemma dmut_wp_produce_chunk {Œì Œ£ Œ£1} (Œ∂1 : Sub Œ£ Œ£1) (c : Chunk _) (s__sym : SymbolicState Œì _)
          (POST : StateProperty Œì Unit _) (POST_dcl : stateprop_downwards_closed POST) :
      dmut_wp (dmut_sub Œ∂1 (dmut_produce_chunk c)) POST s__sym <->
      POST Œ£1 (sub_id Œ£1) tt (symbolicstate_produce_chunk (subst Œ∂1 c) s__sym).
    Proof.
      split.
      - intros dwp.
        specialize (dwp Œ£1 (sub_id Œ£1)). cbn in dwp.
        now rewrite ?sub_comp_id_right, ?subst_sub_id in dwp.
      - intros p Œ£2 Œ∂2. cbn. rewrite subst_sub_comp. revert p.
        rewrite <- subst_symbolicstate_produce_chunk.
        rewrite sub_comp_id_right. change tt with (subst Œ∂2 tt).
        apply POST_dcl. apply dmutres_geq_syn_sem.
        exists Œ∂2. now rewrite sub_comp_id_left.
    Qed.

    Lemma dmut_produce_chunk_sound {Œì Œ£} (Œπ : SymInstance Œ£) (c : Chunk Œ£) :
      box approximates
        (Œì1 := Œì) (Œì2 := Œì) Œπ
        (dmut_produce_chunk c)
        (scmut_produce_chunk (inst Œπ c)).
    Proof.
      intros ? ? ? ? ? ? Hrep ? dwp. cbn.
      apply dmut_wp_produce_chunk in dwp; auto using stateprop_lift_dcl.
      apply (dwp Œπ1); auto using syminstance_rel_refl.
      apply represents_produce_chunk; split; auto.
      rewrite inst_subst. unfold syminstance_rel in H. now subst.
    Qed.

    Lemma dmut_assume_formula_sound {Œì Œ£} (Œπ : SymInstance Œ£) (fml : Formula Œ£) :
      box approximates
        (Œì1 := Œì) (Œì2 := Œì) Œπ
        (dmut_assume_formula fml)
        (scmut_assume_formula Œπ fml).
    Proof.
      intros ? ? ? ? ? ? H__state POST H.
      unfold dmut_wp, dmut_sub, dmut_assume_formula in H.
      specialize (H Œ£1 (sub_id Œ£1)).
      rewrite sub_comp_id_right in H.
      unfold scmut_wp, scmut_assume_formula. cbn. intros.
      rewrite ?subst_sub_id in H.
      destruct (try_solve_formula_spec (subst Œ∂1 fml)).
      - specialize (H2 Œπ1).
        unfold syminstance_rel in H0. subst.
        rewrite inst_subst_formula in H1.
        apply H2 in H1. clear H2.
        unfold is_true in H1. subst a.
        cbn in H.
        rewrite ?sub_comp_id_left in H.
        unfold stateprop_lift in H.
        inster H by apply syminstance_rel_refl.
        now apply H.
      - destruct (dmutres_assume_formula s__sym (subst Œ∂1 fml)) as [Œ£2 Œ∂2 [] s2] eqn:?.
        cbn in H. rewrite sub_comp_id_left in H.
        assert (resultprop_lift Œπ1 POST (dmutres_assume_formula s__sym (subst Œ∂1 fml)))
          by (rewrite Heqd; apply H).
        apply dmutres_assume_formula_spec in H3; auto using resultprop_lift_dcl.
        unfold resultprop_lift, stateprop_lift in H3.
        inster H3 by apply syminstance_rel_refl. apply H3.
        apply represents_assume_formula. split; auto.
        rewrite <- inst_subst_formula. unfold syminstance_rel in H0; now subst.
    Qed.

    Definition dmut_wf {Œì1 Œì2 AT Œ£0 A} `{Inst AT A} (d : DynamicMutator Œì1 Œì2 AT Œ£0) : Prop :=
      forall Œ£1 Œ£2 (Œ∂1 : Sub Œ£0 Œ£1) (Œ∂2 : Sub Œ£1 Œ£2) (s1 : SymbolicState Œì1 Œ£1)
             (POST : ResultProperty Œì2 AT Œ£1) (POST_dcl : resultprop_downwards_closed POST),
        outcome_satisfy (d Œ£1 Œ∂1 s1) POST ->
        outcome_satisfy (d Œ£2 (sub_comp Œ∂1 Œ∂2) (subst Œ∂2 s1)) (resultprop_specialize Œ∂2 POST).

    Lemma dmut_wf_pure {Œì AT Œ£ A} {subA: Subst AT} {sublAT: SubstLaws AT}
          {instA : Inst AT A} {instlA : InstLaws AT A} (a : AT Œ£) :
      dmut_wf (dmut_pure (Œì := Œì) a).
    Proof.
      unfold dmut_wf, resultprop_specialize; cbn; intros.
      revert H.
      apply POST_dcl.
      exists Œ∂2; cbn. intros ? ? rel ? rep.
      split.
      - revert rep. now apply represents_rel.
      - revert rel. intros <-.
        rewrite inst_sub_id, sub_comp_id_right, subst_sub_comp.
        now rewrite ?inst_subst.
    Qed.

    Lemma dmut_wp_sub {Œì1 Œì2 A Œ£0} (d : DynamicMutator Œì1 Œì2 A Œ£0)
          (POST : StateProperty Œì2 A Œ£0) (s : SymbolicState Œì1 Œ£0) Œ£1 (Œ∂ : Sub Œ£0 Œ£1) :
        dmut_wp d POST s ->
        dmut_wp (dmut_sub Œ∂ d) (stateprop_specialize Œ∂ POST) (subst Œ∂ s).
    Proof.
      unfold dmut_sub, dmut_wp. intros * Hpost *.
      specialize (Hpost Œ£2 (sub_comp Œ∂ Œ∂1)).
      rewrite subst_sub_comp in Hpost. revert Hpost.
      apply outcome_satisfy_monotonic. clear. intros [Œ£3 Œ∂3 r3 s3].
      unfold stateprop_specialize. now rewrite sub_comp_assoc.
    Qed.

    (* Definition dmut_wf'' {Œì1 Œì2 A AV Œ£0} `{Inst A AV} (d : DynamicMutator Œì1 Œì2 A Œ£0) : Prop := *)
    (*   forall (POST : StateProperty Œì2 A Œ£0) (POST_dcl : stateprop_downwards_closed POST), *)
    (*     stateprop_downwards_closed *)
    (*       (fun Œ£1 Œ∂1 _ => dmut_wp (dmut_sub Œ∂1 d) (stateprop_specialize Œ∂1 POST)). *)

    (* Lemma dmut_wf''_pure {Œì A Œ£} `{SubstLaws A} (a : A Œ£) : *)
    (*   dmut_wf'' (dmut_pure (Œì := Œì) a). *)
    (* Proof. *)
    (*   unfold dmut_wf''. intros. *)
    (*   unfold dmut_wp, dmut_sub, dmut_pure, stateprop_downwards_closed, stateprop_specialize; cbn; intros. *)
    (*   specialize (H2 _ (sub_comp Œ∂2 Œ∂0)). revert H2. *)
    (*   apply apply_sprop_dcl with (sub_id _); auto; *)
    (*     rewrite ?sub_comp_id_right, ?sub_comp_assoc; auto. *)
    (*   now rewrite subst_sub_id. *)
    (*   unfold state_geq in *. intros ? ? rel ?. *)
    (*   apply syminstance_rel_refl_inv in rel. subst Œπ1. *)
    (*   specialize (H1 _ (inst Œπ0 Œ∂0) eq_refl s__sc). intros rep. *)
    (*   apply (represents_rel eq_refl). unfold sub_comp. *)
    (*   rewrite inst_subst. apply H1. revert rep. *)
    (*   apply (represents_rel eq_refl). *)
    (* Qed. *)

    Lemma dmut_wf_assume_formula {Œì Œ£} (f : Formula Œ£) :
      dmut_wf (@dmut_assume_formula Œì Œ£ f).
    Proof.
      unfold dmut_assume_formula, dmut_wf.
      intros.
      destruct (try_solve_formula (subst Œ∂1 f)) eqn:?; cbn in H.
      - rewrite subst_sub_comp.
        pose proof (try_solve_formula_subst Œ∂2 _ Heqo) as ->.
        revert H. destruct b; cbn; auto.
        apply POST_dcl, dmutres_geq_syn_sem.
        exists Œ∂2. now rewrite sub_comp_id_left, sub_comp_id_right.
      - destruct (try_solve_formula_spec (subst (sub_comp Œ∂1 Œ∂2) f)).
        + destruct a; cbn; auto.
          apply dmutres_assume_formula_spec in H; auto. revert H.
          unfold resultprop_specialize. cbn.
          apply POST_dcl. exists Œ∂2.
          intros ? ? <- ? Hrep.
          apply (represents_rel eq_refl) in Hrep.
          rewrite inst_sub_id, sub_comp_id_right. split; auto.
          apply represents_assume_formula. split; auto.
          rewrite inst_subst_formula, <- subst_sub_comp.
          now apply H0.
        + clear Heqo H0. cbn.
          apply dmutres_assume_formula_spec in H; auto.
          apply dmutres_assume_formula_spec.
          apply resultprop_specialize_dcl; auto.
          unfold resultprop_specialize; cbn.
          revert H. rewrite sub_comp_id_right.
          apply POST_dcl.
          apply dmutres_geq_syn_sem. exists Œ∂2.
          now rewrite sub_comp_id_left, subst_sub_comp, subst_symbolicstate_assume_formula.
    Qed.

    Opaque dmut_assume_formula.
    Opaque subst.
    Opaque sub_up1.
    Opaque sub_snoc.
    Opaque wk1.
    Opaque SubstEnv.

    Lemma dmut_wp_bind {Œì1 Œì2 Œì3 A BT Œ£0 B} {substB : Subst BT} {instB : Inst BT B} (ma : DynamicMutator Œì1 Œì2 A Œ£0)
          (f : forall Œ£', Sub Œ£0 Œ£' -> A Œ£' -> DynamicMutator Œì2 Œì3 BT Œ£')
          (f_wf : forall Œ£' Œ∂ a, dmut_wf (f Œ£' Œ∂ a))
          (POST : StateProperty Œì3 BT Œ£0) (POST_dcl : stateprop_downwards_closed POST) :
      forall s0 : SymbolicState Œì1 Œ£0,
        dmut_wp (dmut_bind ma f) POST s0 <->
        dmut_wp ma (fun Œ£1 Œ∂1 a1 => dmut_wp (f Œ£1 Œ∂1 a1) (stateprop_specialize Œ∂1 POST)) s0.
    Proof.
      unfold DynamicMutator, dmut_bind, dmut_wp, dmut_wf in *; cbn; intros s0.
      split; intros H Œ£1 Œ∂1; specialize (H Œ£1 Œ∂1). revert H.
      - rewrite outcome_satisfy_bind. apply outcome_satisfy_monotonic.
        intros [Œ£2 Œ∂2 a2 s2] H Œ£3 Œ∂3.
        rewrite outcome_satisfy_bind in H.
        apply (f_wf Œ£2 (sub_comp Œ∂1 Œ∂2) a2 Œ£2 Œ£3 (sub_id Œ£2) Œ∂3) in H.
        + revert H. rewrite sub_comp_id_left.
          apply outcome_satisfy_monotonic.
          intros [Œ£4 Œ∂4 b4 s4]. cbn.
          now rewrite <- sub_comp_assoc.
        + clear f_wf H.
          unfold resultprop_downwards_closed.
          intros [Œ£4 Œ∂4 b4 s4] [Œ£5 Œ∂5 b5 s5]. cbn - [dmutres_geq_sem].
          intros Hgeq. apply POST_dcl. rewrite <- ?sub_comp_assoc.
          revert Hgeq. apply dmutres_geq_sem_pre_comp.
      - rewrite outcome_satisfy_bind. revert H.
        apply outcome_satisfy_monotonic.
        intros [Œ£2 Œ∂2 a2 s2] H. specialize (H Œ£2 (sub_id _)).
        revert H. rewrite outcome_satisfy_bind, subst_sub_id.
        apply outcome_satisfy_monotonic.
        intros [Œ£3 Œ∂3 b3 s3]. cbn.
        unfold stateprop_specialize.
        now rewrite sub_comp_id_left, sub_comp_assoc.
    Qed.

    Lemma dmut_wp_sub_bind {A BT B} {subB : Subst BT} {instB : Inst BT B} {Œì1 Œì2 Œì3  Œ£0 Œ£1} (Œ∂1 : Sub Œ£0 Œ£1)
          (ma : DynamicMutator Œì1 Œì2 A Œ£0)
          (f : forall Œ£', Sub Œ£0 Œ£' -> A Œ£' -> DynamicMutator Œì2 Œì3 BT Œ£')
          (f_wf : forall Œ£' Œ∂ a, dmut_wf (f Œ£' Œ∂ a))
          (POST : StateProperty Œì3 BT Œ£1) (POST_dcl : stateprop_downwards_closed POST) :
      forall s0 : SymbolicState Œì1 Œ£1,
        dmut_wp (dmut_sub Œ∂1 (dmut_bind ma f)) POST s0 <->
        dmut_wp
          (dmut_sub Œ∂1 ma)
          (fun Œ£2 Œ∂2 a2 => dmut_wp (f Œ£2 (sub_comp Œ∂1 Œ∂2) a2) (stateprop_specialize Œ∂2 POST))
          s0.
    Proof.
      unfold DynamicMutator, dmut_bind, dmut_sub, dmut_wp, dmut_wf in *; cbn; intros s0.
      split; intros H Œ£2 Œ∂2; specialize (H Œ£2 Œ∂2). revert H.
      - rewrite outcome_satisfy_bind. apply outcome_satisfy_monotonic.
        intros [Œ£3 Œ∂3 a3 s3] H Œ£4 Œ∂4.
        rewrite outcome_satisfy_bind in H.
        apply (f_wf Œ£3 (sub_comp (sub_comp Œ∂1 Œ∂2) Œ∂3) a3 Œ£3 Œ£4 (sub_id Œ£3) Œ∂4) in H.
        + revert H. rewrite sub_comp_id_left, sub_comp_assoc.
          apply outcome_satisfy_monotonic.
          intros [Œ£5 Œ∂5 b5 s5]. cbn.
          now rewrite <- sub_comp_assoc.
        + revert POST_dcl. clear. intros.
          unfold resultprop_downwards_closed.
          intros [Œ£4 Œ∂4 b4 s4] [Œ£5 Œ∂5 b5 s5] Hgeq.
          cbn. apply POST_dcl. rewrite <- ?sub_comp_assoc.
          revert Hgeq. apply dmutres_geq_sem_pre_comp.
      - rewrite outcome_satisfy_bind. revert H.
        apply outcome_satisfy_monotonic.
        intros [Œ£3 Œ∂3 a3 s3] H. specialize (H Œ£3 (sub_id _)).
        revert H. rewrite outcome_satisfy_bind, subst_sub_id, sub_comp_assoc.
        apply outcome_satisfy_monotonic.
        intros [Œ£4 Œ∂4 b4 s4]. cbn.
        unfold stateprop_specialize.
        now rewrite sub_comp_id_left, sub_comp_assoc.
    Qed.

    Lemma dmut_wp_fresh {Œì Œ£0 AT A x œÑ} `{Subst AT, Inst AT A}
          (d : DynamicMutator Œì Œì AT (Œ£0 ‚ñª (x,œÑ))%ctx)
          (POST : StateProperty Œì AT Œ£0)
          (POST_dcl : stateprop_downwards_closed POST)
          (s : SymbolicState Œì Œ£0) (wfd : dmut_wf d) :
      dmut_wp (dmut_fresh (x,œÑ) d) POST s <->
      dmut_wp d (stateprop_specialize sub_wk1 POST) (subst sub_wk1 s).
    Proof.
      unfold dmut_wp, dmut_fresh; cbn; split; intros HYP ? ?.
      - dependent elimination Œ∂1 as [@env_snoc Œ£0 Œ∂1 _ v]; cbn in v.
        rewrite <- subst_sub_comp, sub_comp_wk1_tail; cbn.
        specialize (HYP Œ£1 Œ∂1).
        rewrite outcome_satisfy_map in HYP; cbn in *.
        apply (@wfd _ Œ£1 _ (env_snoc (sub_id _) (_,œÑ) v)) in HYP; clear wfd.
        + change (wk1 (subst Œ∂1 s)) with (subst (sub_wk1 (b:=(x,œÑ))) (subst Œ∂1 s)) in HYP.
          rewrite <- subst_sub_comp, <- sub_snoc_comp, sub_comp_id_right, sub_comp_wk1_tail in HYP.
          cbn in HYP. rewrite subst_sub_id in HYP. revert HYP.
          apply outcome_satisfy_monotonic.
          intros [Œ£2 Œ∂2 r2]. cbn. clear.
          intuition.
          rewrite <- (sub_comp_assoc sub_wk1), sub_comp_wk1_tail in H; cbn in H.
          rewrite sub_comp_id_left in H.
          unfold stateprop_specialize.
          now rewrite <- sub_comp_assoc, sub_comp_wk1_tail.
        + revert POST_dcl. clear. intros.
          unfold resultprop_downwards_closed.
          intros [Œ£2 Œ∂2 a2 s2] [Œ£3 Œ∂3 a3 s3] Hgeq.
          cbn. apply POST_dcl. rewrite <- ?sub_comp_assoc.
          revert Hgeq. apply dmutres_geq_sem_pre_comp.
      - rewrite outcome_satisfy_map.
        specialize (HYP (Œ£1 ‚ñª (x,œÑ)) (sub_up1 Œ∂1)).
        rewrite <- subst_sub_comp, sub_comp_wk1_comm in HYP.
        change (wk1 (b := (x,œÑ)) (subst Œ∂1 s)) with (subst (sub_wk1 (b := (x,œÑ))) (subst Œ∂1 s)).
        rewrite <- subst_sub_comp. revert HYP.
        apply outcome_satisfy_monotonic.
        intros [Œ£2 Œ∂2 r2]. clear.
        dependent elimination Œ∂2 as [@env_snoc Œ£1 Œ∂2 _ t].
        unfold stateprop_specialize.
        now rewrite <- ?sub_comp_assoc, <- sub_comp_wk1_comm.
    Qed.

    Lemma dmut_wp_sub_fresh {Œì Œ£0 Œ£1 AT A x œÑ} `{Subst AT, Inst AT A}
          (Œ∂1 : Sub Œ£0 Œ£1)
          (d : DynamicMutator Œì Œì AT (Œ£0 ‚ñª (x,œÑ))%ctx)
          (POST : StateProperty Œì AT Œ£1)
          (POST_dcl : stateprop_downwards_closed POST)
          (s : SymbolicState Œì Œ£1) (wfd : dmut_wf d) :
      dmut_wp (dmut_sub Œ∂1 (dmut_fresh (x,œÑ) d)) POST s <->
      dmut_wp (dmut_sub (sub_up1 Œ∂1) d) (stateprop_specialize sub_wk1 POST) (subst sub_wk1 s).
    Proof.
      unfold dmut_wp, dmut_sub, dmut_fresh; cbn; split; intros HYP Œ£2 Œ∂2.
      - dependent elimination Œ∂2 as [@env_snoc Œ£1 Œ∂2 _ v]; cbn in v.
        rewrite <- subst_sub_comp, sub_comp_wk1_tail; cbn.
        specialize (HYP Œ£2 Œ∂2).
        rewrite outcome_satisfy_map in HYP; cbn in *.
        apply (@wfd _ Œ£2 _ (env_snoc (sub_id _) (_,œÑ) v)) in HYP; clear wfd.
        + change (wk1 (subst Œ∂2 s)) with (subst (sub_wk1 (b:=(x,œÑ))) (subst Œ∂2 s)) in HYP.
          rewrite <- subst_sub_comp, <- sub_snoc_comp, sub_comp_id_right, sub_comp_wk1_tail in HYP.
          cbn in HYP. rewrite subst_sub_id in HYP.
          rewrite <- sub_snoc_comp. revert HYP.
          apply outcome_satisfy_monotonic.
          intros [Œ£3 Œ∂3 r3]. cbn. clear.
          intuition.
          rewrite <- (sub_comp_assoc sub_wk1), sub_comp_wk1_tail in H; cbn in H.
          rewrite sub_comp_id_left in H.
          unfold stateprop_specialize.
          now rewrite <- sub_comp_assoc, sub_comp_wk1_tail.
        + revert POST_dcl. clear. intros.
          unfold resultprop_downwards_closed.
          intros [Œ£3 Œ∂3 a3 s3] [Œ£4 Œ∂4 a4 s4] Hgeq.
          cbn. apply POST_dcl. rewrite <- ?sub_comp_assoc.
          revert Hgeq. apply dmutres_geq_sem_pre_comp.
      - rewrite outcome_satisfy_map.
        specialize (HYP (Œ£2 ‚ñª (x,œÑ)) (sub_up1 Œ∂2)).
        rewrite <- subst_sub_comp, sub_comp_wk1_comm in HYP.
        change (wk1 (b := (x,œÑ)) (subst Œ∂2 s)) with (subst (sub_wk1 (b := (x,œÑ))) (subst Œ∂2 s)).
        rewrite sub_up_comp, <- subst_sub_comp.
        revert HYP. apply outcome_satisfy_monotonic.
        intros [Œ£3 Œ∂3 r3]. clear.
        dependent elimination Œ∂3 as [@env_snoc Œ£2 Œ∂3 _ t].
        unfold stateprop_specialize.
        now rewrite <- ?sub_comp_assoc, <- sub_comp_wk1_comm.
    Qed.

    Lemma dmut_bind_sound {Œì1 Œì2 Œì3 Œ£0 AT A BT B}
      `{Subst AT, Inst AT A, InstLaws BT B} (Œπ0 : SymInstance Œ£0)
      (dma : DynamicMutator Œì1 Œì2 AT Œ£0) (wfdm : dmut_wf dma)
      (sma : SCMut Œì1 Œì2 A)
      (dmf : forall Œ£1, Sub Œ£0 Œ£1 -> AT Œ£1 -> DynamicMutator Œì2 Œì3 BT Œ£1)
      (dmf_wf : forall Œ£1 Œ∂ a, dmut_wf (dmf Œ£1 Œ∂ a))
      (smf : A -> SCMut Œì2 Œì3 B) :
      box approximates Œπ0 dma sma ->
      (forall Œ£1 (Œ∂1 : Sub Œ£0 Œ£1) (a1 : AT Œ£1) (Œπ1 : SymInstance Œ£1),
          syminstance_rel Œ∂1 Œπ0 Œπ1 ->
          box approximates Œπ1 (dmf Œ£1 Œ∂1 a1) (smf (inst Œπ1 a1))) ->
      box approximates Œπ0 (dmut_bind dma dmf) (scmut_bind sma smf).
    Proof.
      intros H__a H__f.
      intros Œ£1 Œ∂1 Œπ1 relŒπ1 s__sym1 s__sc1 H__rep POST H__wp.
      apply scmut_wp_bind.
      apply dmut_wp_sub_bind in H__wp; auto using stateprop_lift_dcl.
      specialize (H__a Œ£1 Œ∂1 Œπ1 relŒπ1).
      apply H__a with s__sym1. assumption.
      revert H__wp. apply dmut_wp_monotonic.
      intros Œ£2 Œ∂2 a2 s__sym2 H__wp Œπ2 relŒπ2 s__sc2 s__rep2.
      specialize (H__f Œ£2 (sub_comp Œ∂1 Œ∂2) a2 Œπ2).
      inster H__f by eapply syminstance_rel_trans; eauto.
      apply approximates_proj in H__f. eapply H__f. eassumption.
      revert H__wp. apply dmut_wp_monotonic.
      intros Œ£3 Œ∂3 b3 s__sym3 H__post Œπ3 relŒπ3 s__sc3 s__rep3.
      apply H__post. apply (syminstance_rel_trans relŒπ2 relŒπ3). assumption.
    Qed.

    Lemma dmut_fresh_sound {Œì Œ£ œÇ œÑ} (Œπ : SymInstance Œ£)
          (dm : DynamicMutator Œì Œì Unit (Œ£ ‚ñª (œÇ,œÑ))) (wfdm : dmut_wf dm)
          (sm : Lit œÑ -> SCMut Œì Œì unit) :
      (forall v, box approximates (env_snoc Œπ _ v) dm (sm v)) ->
      box approximates Œπ
        (dmut_fresh (œÇ,œÑ) dm)
        (scmut_demonic sm).
    Proof.
      intros HYP. unfold box, approximates.
      intros ? ? ? ? ? ? H__state POST H.
      apply scmut_wp_demonic. intros v.
      specialize (HYP v (Œ£1 ‚ñª (œÇ,œÑ)) (sub_up1 Œ∂1) (env_snoc Œπ1 (œÇ,œÑ) v)).
      inster HYP by apply syminstance_rel_up; auto.
      unfold approximates in HYP.
      apply (HYP (subst (sub_wk1) s__sym)). clear HYP.
      - revert H__state. apply represents_rel, syminstance_rel_wk1.
      - apply (@dmut_wp_sub_fresh Œì Œ£ Œ£1 Unit _ œÇ œÑ SubstUnit InstUnit) in H.
        + revert H; clear.
          apply dmut_wp_monotonic; cbn; intros ? ? []; intros.
          dependent elimination Œ∂ as [@env_snoc Œ£0 Œ∂ _ t].
          unfold stateprop_specialize in H.
          rewrite sub_comp_wk1_tail in H; cbn in *.
          intros Œπ2 H0 s2 H1.
          apply H.
          * now apply syminstance_rel_snoc in H0.
          * assumption.
        + apply stateprop_lift_dcl.
        + assumption.
    Qed.

    Lemma dmut_produce_sound {Œì Œ£} (asn : Assertion Œ£) (Œπ : SymInstance Œ£) :
      box approximates
        (Œì1 := Œì) (Œì2 := Œì) Œπ
        (dmut_produce asn)
        (scmut_produce Œπ asn).
    Proof.
      induction asn; cbn.
      - apply dmut_assume_formula_sound.
      - apply dmut_produce_chunk_sound.
      - apply approximates_demonic_binary.
        + unfold dmut_bind_right.
          eapply dmut_bind_sound.
          apply dmut_wf_assume_formula.
          admit.
          apply dmut_assume_formula_sound.
          intros.
          eapply approximates_sub; eauto.
        + eapply dmut_bind_sound.
          apply dmut_wf_assume_formula.
          admit.
          apply dmut_assume_formula_sound.
          intros.
          eapply approximates_sub; eauto.
      - admit.
      - admit.
      - admit.
      - admit.
      - admit.
      - admit.
      - admit.
      - intros. apply dmut_bind_sound. admit. admit.
        apply IHasn1. intros.
        eapply approximates_sub; eauto.
      - apply dmut_fresh_sound.
        + admit.
        + intros. apply IHasn.
    Admitted.

    Opaque dmut_wp.
    Opaque scmut_wp.

    Section Leftovers.

      Context `{HL: IHeaplet L} {SLL: ISepLogicLaws L}.

      Definition interpret_heap {Œ£} (Œπ : SymInstance Œ£) (h : SymbolicHeap Œ£) : L :=
        List.fold_right (fun c h => ASS.inst_chunk Œπ c ‚àß h) ltrue h.

      Transparent subst SubstEnv.
      Lemma subst_lookup {Œì Œ£ Œ£' x œÉ} (xInŒì : (x ‚à∂ œÉ)%ctx ‚àà Œì) (Œ∂ : Sub Œ£ Œ£') (Œ¥ : SymbolicLocalStore Œì Œ£) :
        (subst Œ∂ (Œ¥ ‚Äº x)%exp = (subst Œ∂ Œ¥ ‚Äº x)%exp).
      Proof.
        unfold subst at 2, subst_localstore, SubstEnv.
        now rewrite env_lookup_map.
      Qed.

      Lemma subst_symboliceval {Œì œÑ Œ£ Œ£'} (e : Exp Œì œÑ) (Œ∂ : Sub Œ£ Œ£') (Œ¥ : SymbolicLocalStore Œì Œ£) :
        subst (T := fun Œ£ => Term Œ£ _) Œ∂ (symbolic_eval_exp Œ¥ e) = symbolic_eval_exp (subst Œ∂ Œ¥) e.
      Proof.
        induction e; cbn; f_equal; auto.
        { now rewrite (subst_lookup xInŒì). }
        all: induction es; cbn in *; destruct_conjs; f_equal; auto.
      Qed.

      Transparent inst instantiate_env.

      Lemma eval_exp_inst {Œì Œ£ œÑ} (Œπ : SymInstance Œ£) (Œ¥ŒìŒ£ : SymbolicLocalStore Œì Œ£) (e : Exp Œì œÑ) :
        eval e (inst Œπ Œ¥ŒìŒ£) = inst Œπ (symbolic_eval_exp Œ¥ŒìŒ£ e).
      Proof.
        induction e; cbn; repeat f_equal; auto.
        { now rewrite env_lookup_map. }
        2: {
          induction es as [|eb n es IHes]; cbn in *.
          { reflexivity. }
          { destruct X as [-> Heqs].
            destruct (inst_term Œπ (symbolic_eval_exp Œ¥ŒìŒ£ eb));
              cbn; f_equal; auto.
          }
        }
        all: induction es; cbn in *; destruct_conjs; f_equal; auto.
      Qed.

    End Leftovers.

  End DynMutV1Soundness.

End Soundness.
